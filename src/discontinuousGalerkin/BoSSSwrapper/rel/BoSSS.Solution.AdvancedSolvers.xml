<?xml version="1.0"?>
<doc>
    <assembly>
        <name>BoSSS.Solution.AdvancedSolvers</name>
    </assembly>
    <members>
        <member name="T:BoSSS.Solution.AdvancedSolvers.AggregationGridBasis">
            <summary>
            DG basis on an aggregation grid (<see cref="T:BoSSS.Foundation.Grid.Aggregation.AggregationGridData"/>).
            </summary>
        </member>
        <member name="M:BoSSS.Solution.AdvancedSolvers.AggregationGridBasis.CreateSequence(System.Collections.Generic.IEnumerable{BoSSS.Foundation.Grid.Aggregation.AggregationGridData},System.Collections.Generic.IEnumerable{BoSSS.Foundation.Basis})">
            <summary>
            Creation of a sequence of aggregation basis objects.
            </summary>
            <param name="_agSeq"></param>
            Sequence of aggregation grids.
            <param name="dgBasisS">
            List of DG basis objects on base grid.
            </param>
            <returns>
            - 1st index: correlates with grid level, i.e. with <paramref name="_agSeq"/>.
            - 2nd index: correlates with DG basis, <paramref name="dgBasisS"/>.
            </returns>
        </member>
        <member name="M:BoSSS.Solution.AdvancedSolvers.AggregationGridBasis.BuildInjector_Lv1(BoSSS.Foundation.Basis,System.Int32,ilPSP.MultidimensionalArray,System.Boolean[],System.Int32,System.Int32[][],System.Int32[][])">
            <summary>
            computes the injector for multigrid level 2 and higher 
            </summary>
            <seealso cref="M:BoSSS.Solution.AdvancedSolvers.AggregationGridBasis.BuildInjector_Lv2andup(BoSSS.Foundation.Basis,System.Int32,ilPSP.MultidimensionalArray,System.Boolean[],System.Int32,System.Int32[][],System.Int32[][])"/>
        </member>
        <member name="M:BoSSS.Solution.AdvancedSolvers.AggregationGridBasis.BuildInjector_Lv2andup(BoSSS.Foundation.Basis,System.Int32,ilPSP.MultidimensionalArray,System.Boolean[],System.Int32,System.Int32[][],System.Int32[][])">
            <summary>
            computes the injector for multigrid level 2 and higher 
            </summary>
            <seealso cref="M:BoSSS.Solution.AdvancedSolvers.AggregationGridBasis.BuildInjector_Lv1(BoSSS.Foundation.Basis,System.Int32,ilPSP.MultidimensionalArray,System.Boolean[],System.Int32,System.Int32[][],System.Int32[][])"/>
        </member>
        <member name="M:BoSSS.Solution.AdvancedSolvers.AggregationGridBasis.#ctor(BoSSS.Foundation.Basis,BoSSS.Solution.AdvancedSolvers.AggregationGridBasis,BoSSS.Foundation.Grid.Aggregation.AggregationGridData,ilPSP.MultidimensionalArray[])">
            <summary>
            Constructor.
            </summary>
            <param name="b">DG basis on original grid</param>
            <param name="ag"></param>
            <param name="Injection">injection operator</param>
            <param name="parentBasis"></param>
        </member>
        <member name="P:BoSSS.Solution.AdvancedSolvers.AggregationGridBasis.UsedMemory">
            <summary>
            Number of Bytes used
            </summary>
        </member>
        <member name="P:BoSSS.Solution.AdvancedSolvers.AggregationGridBasis.InjectionOperator">
            <summary>
            Injection/prolongation operator to finer grid level
            - array index: aggregate cell index; 
            - 1st index into <see cref="T:ilPSP.MultidimensionalArray"/>: index within aggregation basis, correlates with 2nd index into <see cref="P:BoSSS.Foundation.Grid.Aggregation.AggregationGridData.jCellCoarse2jCellFine"/>
            - 2nd index into <see cref="T:ilPSP.MultidimensionalArray"/>: row
            - 3rd index into <see cref="T:ilPSP.MultidimensionalArray"/>: column
            - content: local cell index into the original grid, see <see cref="P:BoSSS.Foundation.Grid.ILogicalCellData.AggregateCellToParts"/>
            </summary>
        </member>
        <member name="M:BoSSS.Solution.AdvancedSolvers.AggregationGridBasis.RestictFromFullGrid``2(``0,``1)">
            <summary>
            restricts/projects a vector from the full grid (<see cref="T:BoSSS.Foundation.Grid.Classic.GridData"/>)
            to the aggregated grid (<see cref="P:BoSSS.Solution.AdvancedSolvers.AggregationGridBasis.AggGrid"/>).
            </summary>
            <param name="FullGridVector">input;</param>
            <param name="AggGridVector">output;</param>
        </member>
        <member name="M:BoSSS.Solution.AdvancedSolvers.AggregationGridBasis.ProlongateToFullGrid``2(``0,``1)">
            <summary>
            Prolongates/injects a vector from 
            the aggregated grid (<see cref="P:BoSSS.Solution.AdvancedSolvers.AggregationGridBasis.AggGrid"/>)
            to the full grid ((<see cref="P:BoSSS.Solution.AdvancedSolvers.AggregationGridBasis.AggGrid"/>, <see cref="P:BoSSS.Foundation.Grid.Aggregation.AggregationGridData.AncestorGrid"/>))
            </summary>
            <param name="FullGridVector">output;</param>
            <param name="AggGridVector">input;</param>
        </member>
        <member name="M:BoSSS.Solution.AdvancedSolvers.AggregationGridBasis.GetRestrictionMatrix(ilPSP.LinSolvers.BlockMsrMatrix,BoSSS.Solution.AdvancedSolvers.MultigridMapping,System.Int32)">
            <summary>
            Restriction operator from the base grid to some multigrid level,
            for a single variable/DG field of a <see cref="T:BoSSS.Solution.AdvancedSolvers.MultigridMapping"/>.
            </summary>
            <param name="rest">Output</param>
            <param name="mgMap"></param>
            <param name="iFld">DG field index within <paramref name="mgMap"/>.</param>
            <remarks>
            Not intended for direct user interaction, mainly used by
            used by <see cref="M:BoSSS.Solution.AdvancedSolvers.MultigridMapping.FromOtherLevelMatrix(BoSSS.Solution.AdvancedSolvers.MultigridMapping)"/>
            </remarks>
        </member>
        <member name="P:BoSSS.Solution.AdvancedSolvers.AggregationGridBasis.DGBasis">
            <summary>
            DG basis on the base grid (<see cref="P:BoSSS.Solution.AdvancedSolvers.AggregationGridBasis.AggGrid"/>, <see cref="P:BoSSS.Foundation.Grid.Aggregation.AggregationGridData.AncestorGrid"/>)
            </summary>
        </member>
        <member name="P:BoSSS.Solution.AdvancedSolvers.AggregationGridBasis.MaximalLength">
            <summary>
            Global maximum (i.e. maximum over all MPI processes) 
            of degrees-of-freedom per cell
            </summary>
        </member>
        <member name="P:BoSSS.Solution.AdvancedSolvers.AggregationGridBasis.MinimalLength">
            <summary>
            Global maximum (i.e. maximum over all MPI processes) 
            of degrees-of-freedom per cell
            </summary>
        </member>
        <member name="M:BoSSS.Solution.AdvancedSolvers.AggregationGridBasis.GetMaximalLength(System.Int32)">
            <summary>
            Global (over all MPI processes) maximum number of degrees-of-freedom per cell for polynomial degree <paramref name="p"/>
            </summary>
        </member>
        <member name="M:BoSSS.Solution.AdvancedSolvers.AggregationGridBasis.GetMinimalLength(System.Int32)">
            <summary>
            Global (over all MPI processes) maximum number of degrees-of-freedom per cell for polynomial degree <paramref name="p"/>
            </summary>
        </member>
        <member name="M:BoSSS.Solution.AdvancedSolvers.AggregationGridBasis.GetLength(System.Int32,System.Int32)">
            <summary>
            number of degrees-of-freedom for polynomial degree <paramref name="p"/> in cell <paramref name="jCell"/>
            </summary>        
        </member>
        <member name="M:BoSSS.Solution.AdvancedSolvers.AggregationGridBasis.GetNoOfSpecies(System.Int32)">
            <summary>
            Always equal 1 for a non-XDG basis.
            </summary>
        </member>
        <member name="P:BoSSS.Solution.AdvancedSolvers.AggregationGridBasis.CompositeBasis">
            <summary>
            **Note: the internal computation of this member is quite expensive and may lead to non-linear runtime behavior w.r.t. the number of cells.
            Use <see cref="M:BoSSS.Solution.AdvancedSolvers.AggregationGridBasis.GetCompositeBasis(System.Int32)"/> if the transformation is only required for a certain cell.**
            The projector in the L2 Norm, from the space defined by the basis <see cref="P:BoSSS.Solution.AdvancedSolvers.AggregationGridBasis.DGBasis"/> on the original,
            onto the DG space on the aggregate grid.
            - array index: aggregate cell index; 
            - 1st index into <see cref="T:ilPSP.MultidimensionalArray"/>: index within aggregation basis 
            - 2nd index into <see cref="T:ilPSP.MultidimensionalArray"/>: row
            - 3rd index into <see cref="T:ilPSP.MultidimensionalArray"/>: column
            - content: local cell index into the original grid, see <see cref="P:BoSSS.Foundation.Grid.ILogicalCellData.AggregateCellToParts"/>
            </summary>
            <remarks>
            This method does not scale linear with problem size, its only here for reference/testing purpose.
            </remarks>
        </member>
        <member name="M:BoSSS.Solution.AdvancedSolvers.AggregationGridBasis.GetCompositeBasis(System.Int32)">
            <summary>
            The projector in the L2 Norm, from the space defined by the basis <see cref="P:BoSSS.Solution.AdvancedSolvers.AggregationGridBasis.DGBasis"/> on the original mesh,
            onto the DG space on the aggregate grid.
            **In contrast to <see cref="P:BoSSS.Solution.AdvancedSolvers.AggregationGridBasis.CompositeBasis"/>, the re-computation is performed only for cell <paramref name="jAgg"/>,
            making this more efficient if only a singe cell is required.**
            </summary>
            <param name="jAgg"></param>
            <returns>
            - 1st index into <see cref="T:ilPSP.MultidimensionalArray"/>: index within aggregation basis 
            - 2nd index into <see cref="T:ilPSP.MultidimensionalArray"/>: row
            - 3rd index into <see cref="T:ilPSP.MultidimensionalArray"/>: column
            </returns>
        </member>
        <member name="M:BoSSS.Solution.AdvancedSolvers.AggregationGridBasis.GetNp">
            <summary>
            Returns a mapping form polynomial degree to DOF per cell.
            </summary>
            <returns></returns>
        </member>
        <member name="P:BoSSS.Solution.AdvancedSolvers.AggregationGridBasis.LocalDim">
            <summary>
            Local vector-space dimension.
            </summary>
        </member>
        <member name="M:BoSSS.Solution.AdvancedSolvers.AggregationGridBasis.N_Murks(System.Int32,System.Int32,System.Int32)">
            <summary>
            This is the DG implementation, which is just the identity.
            For XDG, the cell mode index <paramref name="n"/> may not be equal
            in the full and the aggregated grid. This method performs the transformation.
            </summary>
        </member>
        <member name="M:BoSSS.Solution.AdvancedSolvers.AggregationGridBasis.PlotAggregationBasis(BoSSS.Foundation.Grid.Aggregation.AggregationGridData[],BoSSS.Foundation.Basis,ilPSP.MultidimensionalArray[][])">
            <summary>
            Helper routine to quickly visualize the multigrid basisfunctions on all levels,
            does not yet work in parallel I think.
            </summary>
            <param name="_agGrd"></param>
            <param name="_maxDgBasis"></param>
            <param name="_Injectors"></param>
        </member>
        <member name="M:BoSSS.Solution.AdvancedSolvers.AggregationGridCurvedInjector.AggregateCurvedCells(BoSSS.Foundation.Grid.Aggregation.AggregationGridData,BoSSS.Foundation.Basis,ilPSP.MultidimensionalArray[])">
            <summary>
            The function computes a Np*Np operator for each cell of the grid.
            This operator transforms the basis from aggregation level 0 to the
            maximum aggregation level. It preserves continuity along inner aggregation cell edges
            and the orthonormality of the basis on the aggregation cell. 
            Furthermore it seeks a solution that minimizes the gradient jump along inner edges.
            </summary>
            <param name="_agGrd">Grid Data for the coarse aggregation level</param>
            <param name="_maxDgBasis">underlying DG basis</param>
            <param name="_InjectorCoarse"></param>
            <returns> 
            - index corresponds to the index of the geometric cell
            </returns>
        </member>
        <member name="M:BoSSS.Solution.AdvancedSolvers.AggregationGridCurvedInjector.CheckLinDependency(ilPSP.MultidimensionalArray,System.Int32,System.Int32)">
            returns the inices of rows in Matrix <paramref name="E"/>
            that are linearly independent
        </member>
        <member name="M:BoSSS.Solution.AdvancedSolvers.AggregationGridCurvedInjector.ProjectBasis(BoSSS.Foundation.Grid.Aggregation.AggregationGridData[],BoSSS.Foundation.Basis,ilPSP.MultidimensionalArray[][],ilPSP.MultidimensionalArray[],System.Int32)">
            <summary>
            Calculate an Injection operator by projection of the basis functions from the curved cells on <paramref name="ilevel"/>-1
            to (linear) bounding boxes around the aggregated cells on <paramref name="ilevel"/>. Followed by an reorthonormalization on the aggregated cells.
            </summary>
            <param name="_agGrd"></param>
            <param name="_maxDgBasis"></param>
            <param name="_Injectors"></param> the Injection operator from (level-1 to level) with 1st index level; 2nd index logical (aggregate) cell
            <param name="_injectorCoarse"></param> the direct injector from level 0 to ilevel
            <param name="ilevel"></param>
        </member>
        <member name="T:BoSSS.Solution.AdvancedSolvers.AllSolveConfig">
            <summary>
            Dynamic configuration of multi-level-solvers;
            
            </summary>
        </member>
        <member name="T:BoSSS.Solution.AdvancedSolvers.BlockJacobi">
            <summary>
            Block-Jacobi smoother, maybe only useful in combination with the multi-grid solver (<see cref="T:BoSSS.Solution.AdvancedSolvers.ClassicMultigrid"/>).
            </summary>
        </member>
        <member name="F:BoSSS.Solution.AdvancedSolvers.BlockJacobi.omega">
            <summary>
            Jacobi-Damping
            </summary>
        </member>
        <member name="F:BoSSS.Solution.AdvancedSolvers.BlockJacobi.NoOfIterations">
            <summary>
            Fixed number of block-Jacobi 
            </summary>
        </member>
        <member name="M:BoSSS.Solution.AdvancedSolvers.BlockJacobi.Init(BoSSS.Solution.AdvancedSolvers.MultigridOperator)">
            <summary>
            ~
            </summary>
        </member>
        <member name="M:BoSSS.Solution.AdvancedSolvers.BlockJacobi.Init(BoSSS.Solution.AdvancedSolvers.IOperatorMappingPair)">
            <summary>
            ~
            </summary>
        </member>
        <member name="M:BoSSS.Solution.AdvancedSolvers.BlockJacobi.TerminationCriterion(System.Int32,System.Double,System.Double)">
            <summary>
            ~
            </summary>
        </member>
        <member name="M:BoSSS.Solution.AdvancedSolvers.BlockJacobi.Solve``2(``0,``1)">
            <summary>
            Jacobi iteration
            </summary>
        </member>
        <member name="T:BoSSS.Solution.AdvancedSolvers.CellILU">
            <summary>
            Incomplete LU decomposition on a cell-level
            
            </summary>
        </member>
        <member name="P:BoSSS.Solution.AdvancedSolvers.CellILU.IterationsInNested">
            <summary>
            always 0, no sub-calls here
            </summary>
        </member>
        <member name="P:BoSSS.Solution.AdvancedSolvers.CellILU.ThisLevelIterations">
            <summary>
            
            </summary>
        </member>
        <member name="P:BoSSS.Solution.AdvancedSolvers.CellILU.Converged">
            <summary>
            
            </summary>
        </member>
        <member name="M:BoSSS.Solution.AdvancedSolvers.CellILU.Clone">
            <summary>
            
            </summary>
        </member>
        <member name="M:BoSSS.Solution.AdvancedSolvers.CellILU.Dispose">
            <summary>
            
            </summary>
        </member>
        <member name="M:BoSSS.Solution.AdvancedSolvers.CellILU.Init(BoSSS.Solution.AdvancedSolvers.IOperatorMappingPair)">
            <summary>
            
            </summary>
        </member>
        <member name="M:BoSSS.Solution.AdvancedSolvers.CellILU.Init(BoSSS.Solution.AdvancedSolvers.MultigridOperator)">
            <summary>
            
            </summary>
        </member>
        <member name="M:BoSSS.Solution.AdvancedSolvers.CellILU.InitImpl(BoSSS.Solution.AdvancedSolvers.IOperatorMappingPair)">
            <summary>
            
            </summary>
        </member>
        <member name="M:BoSSS.Solution.AdvancedSolvers.CellILU.ResetStat">
            <summary>
            
            </summary>
        </member>
        <member name="M:BoSSS.Solution.AdvancedSolvers.CellILU.UsedMemory">
            <summary>
            
            </summary>
        </member>
        <member name="F:BoSSS.Solution.AdvancedSolvers.CellILU.BackSubs_Reference.BlockL">
            <summary>
            L-factor of the ILU decomposition
            </summary>
        </member>
        <member name="F:BoSSS.Solution.AdvancedSolvers.CellILU.BackSubs_Reference.BlockU">
            <summary>
            U-factor of the ILU decomposition
            </summary>
        </member>
        <member name="F:BoSSS.Solution.AdvancedSolvers.CellILU.BackSubs_Optimized.m_BlockU_compressed">
            <summary>
            Concatenation of all upper diagonal parts of the U-factor for each block row
            </summary>
        </member>
        <member name="F:BoSSS.Solution.AdvancedSolvers.CellILU.BackSubs_Optimized.m_BlockL_compressed">
            <summary>
            Concatenation of all lower diagonal parts of the L-factor for each block row
            </summary>
        </member>
        <member name="F:BoSSS.Solution.AdvancedSolvers.CellILU.BackSubs_Optimized.L_OccupiedBlockColumnsPerRow">
            <summary>
            Global Column indices of non-zero blocks in the L-factor
            - 1st index: local block-row/cell index
            - 2nd index: enumeration
            </summary>
        </member>
        <member name="F:BoSSS.Solution.AdvancedSolvers.CellILU.BackSubs_Optimized.U_OccupiedBlockColumnsPerRow">
            <summary>
            Global Column indices of non-zero blocks in the U-factor
            - 1st index: local block-row/cell index
            - 2nd index: enumeration
            </summary>
        </member>
        <member name="F:BoSSS.Solution.AdvancedSolvers.CellILU.BackSubs_Optimized.Udiag_lublks">
            <summary>
            LU-decompositions for each diagonal block in the U-factor (upper triangle)
            </summary>
        </member>
        <member name="F:BoSSS.Solution.AdvancedSolvers.CellILU.BackSubs_Optimized.Udiag_inverse">
            <summary>
            inverse for each diagonal block in the U-factor (upper triangle)
            </summary>
        </member>
        <member name="F:BoSSS.Solution.AdvancedSolvers.CellILU.BackSubs_Optimized.Udiag_luipiv">
            <summary>
            pivot indices corresponding with <see cref="F:BoSSS.Solution.AdvancedSolvers.CellILU.BackSubs_Optimized.Udiag_lublks"/>
            </summary>
        </member>
        <member name="F:BoSSS.Solution.AdvancedSolvers.CellILU.BackSubs_Optimized_SinglePrec.m_BlockU_compressed">
            <summary>
            Concatenation of all upper diagonal parts of the U-factor for each block row
            </summary>
        </member>
        <member name="F:BoSSS.Solution.AdvancedSolvers.CellILU.BackSubs_Optimized_SinglePrec.m_BlockL_compressed">
            <summary>
            Concatenation of all lower diagonal parts of the L-factor for each block row
            </summary>
        </member>
        <member name="F:BoSSS.Solution.AdvancedSolvers.CellILU.BackSubs_Optimized_SinglePrec.L_OccupiedBlockColumnsPerRow">
            <summary>
            Global Column indices of non-zero blocks in the L-factor
            - 1st index: local block-row/cell index
            - 2nd index: enumeration
            </summary>
        </member>
        <member name="F:BoSSS.Solution.AdvancedSolvers.CellILU.BackSubs_Optimized_SinglePrec.U_OccupiedBlockColumnsPerRow">
            <summary>
            Global Column indices of non-zero blocks in the U-factor
            - 1st index: local block-row/cell index
            - 2nd index: enumeration
            </summary>
        </member>
        <member name="F:BoSSS.Solution.AdvancedSolvers.CellILU.BackSubs_Optimized_SinglePrec.Udiag_inverse">
            <summary>
            inverse for each diagonal block in the U-factor (upper triangle)
            </summary>
        </member>
        <member name="M:BoSSS.Solution.AdvancedSolvers.CellILU.ComputeILU(System.Int32,ilPSP.LinSolvers.BlockMsrMatrix)">
            <summary>
            ILU, in-place version, after book of Saad (p 303);
            This only considers the MPI-local part of the matrix, i.e. the ILU decomposition is MPI-rank diagonal.
            </summary>
        </member>
        <member name="M:BoSSS.Solution.AdvancedSolvers.CellILU.GetPattern(System.Int32,ilPSP.LinSolvers.BlockMsrMatrix)">
            <summary>
            Obtain occupancy pattern of a <see cref="T:ilPSP.LinSolvers.BlockMsrMatrix"/>;
            this is also an adjacency matrix.
            </summary>
            <returns>
            A matrix with one entry for each block of the input matrix <paramref name="Mtx"/>
            </returns>
        </member>
        <member name="M:BoSSS.Solution.AdvancedSolvers.CellILU.CheckILU(System.Int32,ilPSP.LinSolvers.BlockMsrMatrix,ilPSP.LinSolvers.BlockMsrMatrix,ilPSP.LinSolvers.BlockMsrMatrix)">
            <summary>
            Verifies that, within the occupancy pattern of <paramref name="OperatorMatrix"/>,
            the product of <paramref name="m_BlockU"/>*<paramref name="m_BlockL"/> is equal to the <paramref name="OperatorMatrix"/>
            </summary>
        </member>
        <member name="T:BoSSS.Solution.AdvancedSolvers.ClassicMultigrid">
            <summary>
            Multigrid methods for linear systems, using pre- and post-smoother (<see cref="F:BoSSS.Solution.AdvancedSolvers.ClassicMultigrid.PreSmoother"/>, <see cref="F:BoSSS.Solution.AdvancedSolvers.ClassicMultigrid.PostSmoother"/>) as well as coarse-grid correction (<see cref="F:BoSSS.Solution.AdvancedSolvers.ClassicMultigrid.CoarserLevelSolver"/>).
            </summary>
        </member>
        <member name="T:BoSSS.Solution.AdvancedSolvers.ClassicMultigrid.Config">
            <summary>
            Individual configuration of <see cref="T:BoSSS.Solution.AdvancedSolvers.OrthonormalizationMultigrid"/>
            </summary>
        </member>
        <member name="M:BoSSS.Solution.AdvancedSolvers.ClassicMultigrid.Config.#ctor">
            <summary>
            Ctor
            </summary>
        </member>
        <member name="F:BoSSS.Solution.AdvancedSolvers.ClassicMultigrid.Config.CoarseOnLovwerLevel">
            <summary>
            - True: the default value: <see cref="F:BoSSS.Solution.AdvancedSolvers.ClassicMultigrid.CoarserLevelSolver"/> is initialized and solved on coarser level
            - false: <see cref="F:BoSSS.Solution.AdvancedSolvers.ClassicMultigrid.CoarserLevelSolver"/> is initialized on the same level, but it may perform tis own restriction
            </summary>
        </member>
        <member name="F:BoSSS.Solution.AdvancedSolvers.ClassicMultigrid.Config.m_omega">
            <summary>
            - if set to 1, a this performs a V-cycle
            - if set to 2 or higher, a W-cycle, resp. WW-cycle, WWW-cycle, etc.
            </summary>
        </member>
        <member name="P:BoSSS.Solution.AdvancedSolvers.ClassicMultigrid.Config.Name">
            <summary>
            
            </summary>
        </member>
        <member name="P:BoSSS.Solution.AdvancedSolvers.ClassicMultigrid.Config.Shortname">
            <summary>
            
            </summary>
        </member>
        <member name="M:BoSSS.Solution.AdvancedSolvers.ClassicMultigrid.Config.CreateInstance(BoSSS.Solution.AdvancedSolvers.MultigridOperator)">
            <summary>
            factory
            </summary>
        </member>
        <member name="P:BoSSS.Solution.AdvancedSolvers.ClassicMultigrid.config">
            <summary>
            Solver configuration
            </summary>
        </member>
        <member name="M:BoSSS.Solution.AdvancedSolvers.ClassicMultigrid.InitMultigridChain(BoSSS.Solution.AdvancedSolvers.MultigridOperator,System.Func{System.Int32,BoSSS.Solution.AdvancedSolvers.ISolverSmootherTemplate},System.Func{System.Int32,BoSSS.Solution.AdvancedSolvers.ISolverSmootherTemplate},System.Action{System.Int32,BoSSS.Solution.AdvancedSolvers.ClassicMultigrid},System.Func{BoSSS.Solution.AdvancedSolvers.ISolverSmootherTemplate})">
            <summary>
            Creates a V- or W-cycle (depending on <see cref="F:BoSSS.Solution.AdvancedSolvers.ClassicMultigrid.Config.m_omega"/>) of multi-grid methods, 
            with each multi-grid solver being the coarse-level solver for the finer level.
            </summary>
        </member>
        <member name="M:BoSSS.Solution.AdvancedSolvers.ClassicMultigrid.InitMultigridChain(System.Collections.Generic.IEnumerable{BoSSS.Foundation.Grid.Aggregation.AggregationGridData},System.Func{System.Int32,BoSSS.Solution.AdvancedSolvers.ISolverSmootherTemplate},System.Func{System.Int32,BoSSS.Solution.AdvancedSolvers.ISolverSmootherTemplate},System.Action{System.Int32,BoSSS.Solution.AdvancedSolvers.ClassicMultigrid},System.Func{BoSSS.Solution.AdvancedSolvers.ISolverSmootherTemplate},System.Int32)">
            <summary>
            Creates a V- or W-cycle (depending on <see cref="F:BoSSS.Solution.AdvancedSolvers.ClassicMultigrid.Config.m_omega"/>) of multi-grid methods, 
            with each multi-grid solver being the coarse-level solver for the finer level.
            </summary>
        </member>
        <member name="P:BoSSS.Solution.AdvancedSolvers.ClassicMultigrid.OpMatrix">
            <summary>
            The matrix at this level.
            </summary>
        </member>
        <member name="M:BoSSS.Solution.AdvancedSolvers.ClassicMultigrid.InitImpl(BoSSS.Solution.AdvancedSolvers.IOperatorMappingPair)">
            <summary>
            defines the problem matrix
            </summary>
        </member>
        <member name="M:BoSSS.Solution.AdvancedSolvers.ClassicMultigrid.Residual``3(``0,``1,``2)">
            <summary>
            computes the residual on this level.
            </summary>
        </member>
        <member name="P:BoSSS.Solution.AdvancedSolvers.ClassicMultigrid.TerminationCriterion">
            <summary>
            ~
            </summary>
        </member>
        <member name="M:BoSSS.Solution.AdvancedSolvers.ClassicMultigrid.#ctor">
            <summary>
            ctor
            </summary>
        </member>
        <member name="M:BoSSS.Solution.AdvancedSolvers.ClassicMultigrid.Solve``2(``0,``1)">
            <summary>
            the multigrid iterations for a linear problem
            </summary>
            <param name="xl">on input, the initial guess; on exit, the result of the multigrid iteration</param>
            <param name="bl">the right-hand-side of the problem</param>
        </member>
        <member name="P:BoSSS.Solution.AdvancedSolvers.ClassicMultigrid.IterationsInNested">
            <summary>
            ~
            </summary>
        </member>
        <member name="T:BoSSS.Solution.AdvancedSolvers.Testing.ConditionNumberScalingTest">
            <summary>
            Utility class for executing a series of solver runs and studying the condition number slope over mesh resolution;
            Works only for solvers which implemented <see cref="M:BoSSS.Solution.Application`1.OperatorAnalysis"/>,
            see also <see cref="M:BoSSS.Solution.AdvancedSolvers.Testing.OpAnalysisBase.GetNamedProperties"/>
            </summary>
        </member>
        <member name="M:BoSSS.Solution.AdvancedSolvers.Testing.ConditionNumberScalingTest.Perform(System.Collections.Generic.IEnumerable{BoSSS.Solution.Control.AppControl},System.Boolean,System.String,System.Boolean)">
            <summary>
            Easy-to-use driver routine
            </summary>
            <param name="controls">
            a set of control object over which the scaling is investigated
            </param>
            <param name="plot">
            if true, an interactive Gnuplot session is opened
            </param>
            <param name="title">
            Gnuplot title/output filename
            </param>
            <param name="ThrowAssertions">
            assertions are thrown if the slopes of the condition number are too high, c.f. <see cref="F:BoSSS.Solution.AdvancedSolvers.Testing.ConditionNumberScalingTest.ExpectedSlopes"/>;
            should always be true for testing
            </param>
            <returns>
            <see cref="P:BoSSS.Solution.AdvancedSolvers.Testing.ConditionNumberScalingTest.ResultData"/>
            </returns>
        </member>
        <member name="M:BoSSS.Solution.AdvancedSolvers.Testing.ConditionNumberScalingTest.Plot">
            <summary>
            Interactive plotting using gnuplot.
            </summary>
        </member>
        <member name="M:BoSSS.Solution.AdvancedSolvers.Testing.ConditionNumberScalingTest.#ctor(System.String)">
            <summary>
            ctor
            </summary>
            <param name="Title">
            Optional title used for plots, etc.
            </param>
        </member>
        <member name="M:BoSSS.Solution.AdvancedSolvers.Testing.ConditionNumberScalingTest.SetControls(System.Collections.Generic.IEnumerable{BoSSS.Solution.Control.AppControl})">
            <summary>
            A range of control objects over which the condition number scaling is performed.
            </summary>
        </member>
        <member name="T:BoSSS.Solution.AdvancedSolvers.Testing.ConditionNumberScalingTest.MyEnu">
            <summary>
            Entsetzlich viel code für was primitives
            </summary>
        </member>
        <member name="M:BoSSS.Solution.AdvancedSolvers.Testing.ConditionNumberScalingTest.SetControls(BoSSS.Solution.Control.AppControl,System.Collections.Generic.IEnumerable{System.Func{BoSSS.Foundation.Grid.IGrid}})">
            <summary>
            A range of control objects over which the condition number scaling is performed.
            </summary>
            <param name="BaseControl">
            basic settings
            </param>
            <param name="GridFuncs">
            a sequence of grid-generating functions, (<see cref="F:BoSSS.Solution.Control.AppControl.GridFunc"/>),
            which defines the grid for each run
            </param>
        </member>
        <member name="F:BoSSS.Solution.AdvancedSolvers.Testing.ConditionNumberScalingTest.ExpectedSlopes">
            <summary>
            One tuple for each slope that should be tested
            - 1st item: name of x-axis
            - 2nd item: name of y-axis (wildcards accepted)
            - 3rd item expected slope in the log-log-regression
            - 4th item lower bound for expected slope in the log-log-regression
            </summary>
        </member>
        <member name="M:BoSSS.Solution.AdvancedSolvers.Testing.ConditionNumberScalingTest.PrintResults(System.IO.TextWriter)">
            <summary>
            Phase 2, Examination: prints slope thresholds to console output. 
            </summary>
        </member>
        <member name="M:BoSSS.Solution.AdvancedSolvers.Testing.ConditionNumberScalingTest.CheckResults">
            <summary>
            Phase 2, Examination: checks slope thresholds with NUnit assertions. 
            </summary>
        </member>
        <member name="P:BoSSS.Solution.AdvancedSolvers.Testing.ConditionNumberScalingTest.ResultData">
            <summary>
            Stores the result of <see cref="M:BoSSS.Solution.AdvancedSolvers.Testing.ConditionNumberScalingTest.RunAndLog"/>; Contains
            a table, containing grid resolutions and measurements on condition number
            - keys: column names
            - values: measurements of each column
            </summary>
        </member>
        <member name="F:BoSSS.Solution.AdvancedSolvers.Testing.ConditionNumberScalingTest.RunNumber">
            <summary>
            
            </summary>
        </member>
        <member name="M:BoSSS.Solution.AdvancedSolvers.Testing.ConditionNumberScalingTest.RunAndLog">
            <summary>
            Phase 1: runs the solvers and stores results in <see cref="P:BoSSS.Solution.AdvancedSolvers.Testing.ConditionNumberScalingTest.ResultData"/>.
            Utility routine, performs an operator analysis on a sequence of control objects and returns a table of results.
            </summary>
        </member>
        <member name="T:BoSSS.Solution.AdvancedSolvers.Testing.ConditionNumberScalingTest.XAxisDesignation">
            <summary>
            Names for the x-axis, over which condition number scaling slopes are computed.
            </summary>
        </member>
        <member name="F:BoSSS.Solution.AdvancedSolvers.Testing.ConditionNumberScalingTest.XAxisDesignation.Grid_NoOfCells">
            <summary>
            total number of cells, <see cref="P:BoSSS.Foundation.Grid.IGridData.CellPartitioning"/>
            </summary>
        </member>
        <member name="F:BoSSS.Solution.AdvancedSolvers.Testing.ConditionNumberScalingTest.XAxisDesignation.Grid_hMin">
            <summary>
            maximum cell size, <see cref="P:BoSSS.Foundation.Grid.IGeometricalCellsData.h_min"/>
            </summary>
        </member>
        <member name="F:BoSSS.Solution.AdvancedSolvers.Testing.ConditionNumberScalingTest.XAxisDesignation.Grid_hMax">
            <summary>
            maximum cell size, <see cref="P:BoSSS.Foundation.Grid.IGeometricalCellsData.h_max"/>
            </summary>
        </member>
        <member name="F:BoSSS.Solution.AdvancedSolvers.Testing.ConditionNumberScalingTest.XAxisDesignation.Grid_1Dres">
            <summary>
            D-th root of number of cells, where D is the spatial dimension
            </summary>
        </member>
        <member name="T:BoSSS.Solution.AdvancedSolvers.Testing.OpAnalysisBase">
            <summary>
            Numerical testing of coupled operators
            </summary>
        </member>
        <member name="M:BoSSS.Solution.AdvancedSolvers.Testing.OpAnalysisBase.#ctor(ilPSP.LinSolvers.BlockMsrMatrix,System.Double[],BoSSS.Foundation.UnsetteledCoordinateMapping,System.Collections.Generic.IEnumerable{BoSSS.Solution.AdvancedSolvers.MultigridOperator.ChangeOfBasisConfig[]},BoSSS.Foundation.ISpatialOperator)">
            <summary>
            Constructor for DG solvers
            </summary>
        </member>
        <member name="M:BoSSS.Solution.AdvancedSolvers.Testing.OpAnalysisBase.#ctor(BoSSS.Foundation.XDG.LevelSetTracker,ilPSP.LinSolvers.BlockMsrMatrix,System.Double[],BoSSS.Foundation.UnsetteledCoordinateMapping,BoSSS.Foundation.XDG.MultiphaseCellAgglomerator,ilPSP.LinSolvers.BlockMsrMatrix,System.Collections.Generic.IEnumerable{BoSSS.Solution.AdvancedSolvers.MultigridOperator.ChangeOfBasisConfig[]},BoSSS.Foundation.ISpatialOperator)">
            <summary>
            Constructor for XDG solvers
            </summary>
        </member>
        <member name="P:BoSSS.Solution.AdvancedSolvers.Testing.OpAnalysisBase.MultigridOp">
            <summary>
            Les operaeur
            </summary>
        </member>
        <member name="P:BoSSS.Solution.AdvancedSolvers.Testing.OpAnalysisBase.VarGroup">
            <summary>
            user-defined indices of depended variables, if not the full matrix should be analyzed, e.g. 0 = u_x, 1=u_y, 2=u_z, 3=p ...
            </summary>
        </member>
        <member name="M:BoSSS.Solution.AdvancedSolvers.Testing.OpAnalysisBase.MinimalEigen">
            <summary>
            Computes the minimal Eigenvalue and related Eigenvector using PARDISO
            </summary>
        </member>
        <member name="M:BoSSS.Solution.AdvancedSolvers.Testing.OpAnalysisBase.Analyse">
            <summary>
            fully analyses the matrix with
            - condition number,
            - symmetric positive definiteness,
            - maximum and minimum eigenvalues and
            - the existence of a unique solution
            </summary>
        </member>
        <member name="M:BoSSS.Solution.AdvancedSolvers.Testing.OpAnalysisBase.rankAnalysis(ilPSP.LinSolvers.BlockMsrMatrix,System.Double[])">
            <summary>
            According to the Rouché-Capelli theorem, the system is inconsistent if rank(augMatrix) > rank(Matrix). 
            If rank(augMatrix) == rank(Matrix), the system has at least one solution.
            Additionally, if the rank is equal to the number of variables, the solution of the system is unique.
            Remark: This requires the whole RHS not only local!!!
            </summary>
            <param name="OpMatrix"></param>
            <param name="RHS"></param>
        </member>
        <member name="M:BoSSS.Solution.AdvancedSolvers.Testing.OpAnalysisBase.CondNumMUMPS">
            <summary>
            returns the condition number of the full matrix using MUMPS;
            From manual it is unclear in which norm the cond num is calculated
            results from parallel and single execution differ!
            </summary>
        </member>
        <member name="M:BoSSS.Solution.AdvancedSolvers.Testing.OpAnalysisBase.CondNumMatlab2">
            <summary>
            returns the condition number of the full matrix and the inner matrix without boundary terms
            </summary>
            <returns>
            [ConditionNumberFullOp, ConditionNumberInnerOp]
            </returns>
        </member>
        <member name="M:BoSSS.Solution.AdvancedSolvers.Testing.OpAnalysisBase.GetAlternativeMgOp(BoSSS.Solution.AdvancedSolvers.MultigridOperator.Mode)">
            <summary>
            Creates a new <see cref="T:BoSSS.Solution.AdvancedSolvers.MultigridOperator"/>, where all variables in <see cref="P:BoSSS.Solution.AdvancedSolvers.Testing.OpAnalysisBase.VarGroup"/> are preconditioned according to <paramref name="altMode"/>.
            (All Variables **not** in <see cref="P:BoSSS.Solution.AdvancedSolvers.Testing.OpAnalysisBase.VarGroup"/> are not preconditioned, i.e. the option <see cref="F:BoSSS.Solution.AdvancedSolvers.MultigridOperator.Mode.Eye"/> is chosen.
            </summary>
        </member>
        <member name="P:BoSSS.Solution.AdvancedSolvers.Testing.OpAnalysisBase.PrecondOpMatrix">
            <summary>
            The operator matrix after compactification (i.e. elimination of un-used DOFs),
            application of reference points (<see cref="P:BoSSS.Foundation.ISpatialOperator.FreeMeanValue"/>),
            and block-preconditioning.
            </summary>
        </member>
        <member name="M:BoSSS.Solution.AdvancedSolvers.Testing.OpAnalysisBase.CondNumMatlab">
            <summary>
            returns the condition number of the full matrix
            </summary>
        </member>
        <member name="M:BoSSS.Solution.AdvancedSolvers.Testing.OpAnalysisBase.Symmetry">
            <summary>
            Test if the matrix is symmetric positive definite
            </summary>
            <returns>bool array res=[symmetry, positive definit]</returns>
        </member>
        <member name="M:BoSSS.Solution.AdvancedSolvers.Testing.OpAnalysisBase.Eigenval">
            <summary>
            returns the maximum and minimum eigenvalues of the matrix
            </summary>
            <returns>Array myeigs =[MaximumEig, MinimumEig]</returns>
        </member>
        <member name="M:BoSSS.Solution.AdvancedSolvers.Testing.OpAnalysisBase.BlockCondNumbers">
            <summary>
            Local condition number for the block formed by each cell.
            </summary>
            <returns>
            one value per cell:
            - index: local cell index
            - content: condition number (one norm) of the local stencil
            </returns>
        </member>
        <member name="M:BoSSS.Solution.AdvancedSolvers.Testing.OpAnalysisBase.StencilCondNumbers">
            <summary>
            Local condition number formed by the block of each cell and its neighbors.
            </summary>
            <returns>
            one value per cell:
            - index: local cell index
            - content: condition number (one norm) of the local stencil
            </returns>
        </member>
        <member name="M:BoSSS.Solution.AdvancedSolvers.Testing.OpAnalysisBase.StencilCondNumbersV">
            <summary>
            Local condition number formed by the block of each cell and its neighbors, visualized as a degree-0 DG field.
            </summary>
            <returns>
            a DG field of degree 0, where the average value in each cell represents the respective local condition number
            </returns>
        </member>
        <member name="P:BoSSS.Solution.AdvancedSolvers.Testing.OpAnalysisBase.VarNames">
            <summary>
            Turn VarGroup into Names
            </summary>
        </member>
        <member name="M:BoSSS.Solution.AdvancedSolvers.Testing.OpAnalysisBase.GetNamedProperties">
            <summary>
            Various condition numbers, organized in a dictionary to create a regression over multiple meshes
            </summary>
        </member>
        <member name="T:BoSSS.Solution.AdvancedSolvers.ConvergenceObserver">
            <summary>
            A helper class to analyze and visualize the convergence of an iterative solver algorithm.
            - writes tecplot files containing the residuals, error (if the solution is known), <see cref="F:BoSSS.Solution.AdvancedSolvers.ConvergenceObserver.TecplotOut"/>.
            - records convergence trends for different grid and \f$ p \f$-levels.
            </summary>
        </member>
        <member name="M:BoSSS.Solution.AdvancedSolvers.ConvergenceObserver.WaterfallAnalysis(BoSSS.Solution.AdvancedSolvers.ISolverWithCallback,BoSSS.Solution.AdvancedSolvers.MultigridOperator,ilPSP.LinSolvers.BlockMsrMatrix)">
            <summary>
            Performs a mode decay analysis (<see cref="M:BoSSS.Solution.AdvancedSolvers.ConvergenceObserver.Waterfall(System.Boolean,System.Boolean,System.Int32)"/>) on this solver.
            </summary>
        </member>
        <member name="M:BoSSS.Solution.AdvancedSolvers.ConvergenceObserver.#ctor(BoSSS.Solution.AdvancedSolvers.MultigridOperator,ilPSP.LinSolvers.BlockMsrMatrix,System.Double[])">
            <summary>
            ctor
            </summary>
        </member>
        <member name="M:BoSSS.Solution.AdvancedSolvers.ConvergenceObserver.#ctor(BoSSS.Solution.AdvancedSolvers.MultigridOperator,ilPSP.LinSolvers.BlockMsrMatrix,System.Double[],BoSSS.Solution.AdvancedSolvers.ISolverFactory)">
            <summary>
            another constructor
            </summary>
        </member>
        <member name="P:BoSSS.Solution.AdvancedSolvers.ConvergenceObserver.DecompositionOperator">
            <summary>
            Used to compute an orthonormal decomposition 
            </summary>
        </member>
        <member name="F:BoSSS.Solution.AdvancedSolvers.ConvergenceObserver.ResNormTrend">
            <summary>
            L2-norm of the residual per variable, multigrid level and DG polynomial degree;
            - 1st index: multigrid level index
            - 2nd index: variable index
            - 3rd index: polynomial degree
            </summary>
        </member>
        <member name="F:BoSSS.Solution.AdvancedSolvers.ConvergenceObserver.ErrNormTrend">
            <summary>
            L2-norm of the error per variable, multigrid level and DG polynomial degree;
            - 1st index: multigrid level index
            - 2nd index: variable index
            - 3rd index: polynomial degree 
            </summary>
        </member>
        <member name="M:BoSSS.Solution.AdvancedSolvers.ConvergenceObserver.PlotIterationTrend(System.Boolean,System.Boolean,System.Boolean,System.Boolean)">
            <summary>
            Visualization of data from <see cref="M:BoSSS.Solution.AdvancedSolvers.ConvergenceObserver.WriteTrendToTable(System.Boolean,System.Boolean,System.Boolean,System.Boolean,System.String[]@,ilPSP.MultidimensionalArray@)"/> in gnuplot
            </summary>
        </member>
        <member name="M:BoSSS.Solution.AdvancedSolvers.ConvergenceObserver.Waterfall(System.Boolean,System.Boolean,System.Int32)">
            <summary>
            Visualization of error data from <see cref="M:BoSSS.Solution.AdvancedSolvers.ConvergenceObserver.WriteTrendToTable(System.Boolean,System.Boolean,System.Boolean,System.Boolean,System.String[]@,ilPSP.MultidimensionalArray@)"/> in gnuplot
            </summary>
        </member>
        <member name="M:BoSSS.Solution.AdvancedSolvers.ConvergenceObserver.WriteTrendToCSV(System.Boolean,System.Boolean,System.Boolean,System.Boolean,System.String)">
            <summary>
            Writes the table obtained through <see cref="M:BoSSS.Solution.AdvancedSolvers.ConvergenceObserver.WriteTrendToTable(System.Boolean,System.Boolean,System.Boolean,System.Boolean,System.String[]@,ilPSP.MultidimensionalArray@)"/> into a CSV file.
            </summary>
        </member>
        <member name="M:BoSSS.Solution.AdvancedSolvers.ConvergenceObserver.WriteTrendToTable(System.Boolean,System.Boolean,System.Boolean,System.Boolean,System.String[]@,ilPSP.MultidimensionalArray@)">
            <summary>
            provides data collected during a solver run in tabular form
            </summary>
            <param name="ErrorOrResidual">
            - true: output is error against exact solution (if provided) during each iteration
            - false: output is residual against exact solution (if provided) during each iteration
            </param>
            <param name="SepVars">
            - true: separate column for each variable
            - false:  l2-norm over all variables
            </param>
            <param name="SepPoly">
            - true:   separate column for each polynomial degree
            - false:  l2-norm over all polynomial degrees
            </param>
            <param name="SepLev">
            - true:   separate column for each multi-grid level
            - false:  l2-norm over all multi-grid levels
            </param>
            <param name="Titels">
            Column names/titles
            </param>
            <param name="ConvTrendData">
            data table:
            - columns: correspond to <paramref name="Titels"/>
            - rows: solver iterations
            </param>
        </member>
        <member name="M:BoSSS.Solution.AdvancedSolvers.ConvergenceObserver.PlotDecomposition``1(``0,System.String)">
            <summary>
            Decomposition of some solution vector <paramref name="vec"/> into the different multigrid levels.
            </summary>
            <param name="vec">
            approximate solution
            </param>
            <param name="plotName">
            name of the tecplot file
            </param>
        </member>
        <member name="M:BoSSS.Solution.AdvancedSolvers.ConvergenceObserver.OrthonormalMultigridDecomposition(System.Double[],System.Boolean)">
            <summary>
            Decomposition of a certain vector into its frequencies on all mesh levels.
            </summary>
            <param name="Vec"></param>
            <param name="decompose">
            - true: orthogonality (of the respective DG/XDG) representation across all mesh levels:
                    the high level modes contain only contributions which cannot be represented on the lower levels.
            - false: the higher level meshes include also lower frequencies;
            </param>
            <returns>
            - one vector per multigrid level
            </returns>
        </member>
        <member name="F:BoSSS.Solution.AdvancedSolvers.ConvergenceObserver.TecplotOut">
            <summary>
            Basis filename for the Tecplot output.
            </summary>
        </member>
        <member name="F:BoSSS.Solution.AdvancedSolvers.ConvergenceObserver.LastResidualNorm">
            <summary>
            L2 norm of residual in last/most recent iteration
            </summary>
        </member>
        <member name="F:BoSSS.Solution.AdvancedSolvers.ConvergenceObserver.LastSolNorm">
            <summary>
            L2 norm of solution (= error against 0 RHS) in last/most recent iteration
            </summary>
        </member>
        <member name="F:BoSSS.Solution.AdvancedSolvers.ConvergenceObserver.Iter0ResidualNorm">
            <summary>
            L2 norm of residual in first iteration
            </summary>
        </member>
        <member name="F:BoSSS.Solution.AdvancedSolvers.ConvergenceObserver.Iter0SolNorm">
            <summary>
            L2 norm of solution (= error against 0 RHS) in first recent iteration
            </summary>
        </member>
        <member name="F:BoSSS.Solution.AdvancedSolvers.ConvergenceObserver.NumberOfIterations">
            <summary>
            Highest iteration number
            </summary>
        </member>
        <member name="M:BoSSS.Solution.AdvancedSolvers.ConvergenceObserver.IterationCallback(System.Int32,System.Double[],System.Double[],BoSSS.Solution.AdvancedSolvers.MultigridOperator)">
            <summary>
            Callback routine, see <see cref="P:BoSSS.Solution.AdvancedSolvers.ISolverWithCallback.IterationCallback"/> or <see cref="E:BoSSS.Solution.AdvancedSolvers.NonlinearSolver.IterationCallback"/>.
            </summary>
        </member>
        <member name="M:BoSSS.Solution.AdvancedSolvers.ConvergenceObserver.WriteTrendToSession(BoSSS.Foundation.IO.IFileSystemDriver,BoSSS.Foundation.IO.SessionInfo)">
            <summary>
            
            </summary>
            <param name="FsDriver"></param>
            <param name="SI"></param>
        </member>
        <member name="T:BoSSS.Solution.AdvancedSolvers.DirectSolver">
            <summary>
            Sparse direct solver. 
            This class is a wrapper around either 
            - PARDISO (<see cref="T:ilPSP.LinSolvers.PARDISO.PARDISOSolver"/>) or 
            - MUMPS (<see cref="T:ilPSP.LinSolvers.MUMPS.MUMPSSolver"/>) or
            - LAPACK.
            </summary>
        </member>
        <member name="T:BoSSS.Solution.AdvancedSolvers.DirectSolver.Config">
            <summary>
            
            </summary>
        </member>
        <member name="F:BoSSS.Solution.AdvancedSolvers.DirectSolver.Config.WhichSolver">
            <summary>
            Switch between PARDISO and MUMPS.
            </summary>
        </member>
        <member name="P:BoSSS.Solution.AdvancedSolvers.DirectSolver.Config.Name">
            <summary>
            
            </summary>
        </member>
        <member name="P:BoSSS.Solution.AdvancedSolvers.DirectSolver.Config.Shortname">
            <summary>
            
            </summary>
        </member>
        <member name="M:BoSSS.Solution.AdvancedSolvers.DirectSolver.Config.CreateInstance(BoSSS.Solution.AdvancedSolvers.MultigridOperator)">
            <summary>
            
            </summary>
        </member>
        <member name="M:BoSSS.Solution.AdvancedSolvers.DirectSolver.Config.Equals(BoSSS.Solution.AdvancedSolvers.ISolverFactory)">
            <summary>
            
            </summary>
        </member>
        <member name="M:BoSSS.Solution.AdvancedSolvers.DirectSolver.Config.Equals(System.Object)">
            <summary>
            
            </summary>
        </member>
        <member name="P:BoSSS.Solution.AdvancedSolvers.DirectSolver.Config.TestSolution">
            <summary>
            If set to true, the solution returned by the direct solver is tested by computing the residual norm.
            Currently, the default is true, since the direct solvers seem unreliable.
            </summary>
        </member>
        <member name="P:BoSSS.Solution.AdvancedSolvers.DirectSolver.Config.UseDoublePrecision">
            <summary>
            - true: use double precision floats internally (default)
            - false: use single precision; might be useful for solution guesses in preconditioners; only supported for <see cref="F:BoSSS.Solution.AdvancedSolvers.DirectSolver.Config.WhichSolver"/>==<see cref="F:BoSSS.Solution.AdvancedSolvers.DirectSolver._whichSolver.PARDISO"/>.
            </summary>
        </member>
        <member name="P:BoSSS.Solution.AdvancedSolvers.DirectSolver.config">
            <summary>
            Solver configuration
            </summary>
        </member>
        <member name="T:BoSSS.Solution.AdvancedSolvers.DirectSolver._whichSolver">
            <summary>
            
            </summary>
        </member>
        <member name="F:BoSSS.Solution.AdvancedSolvers.DirectSolver._whichSolver.PARDISO">
            <summary>
            Using <see cref="T:ilPSP.LinSolvers.PARDISO.PARDISOSolver"/>.
            </summary>
        </member>
        <member name="F:BoSSS.Solution.AdvancedSolvers.DirectSolver._whichSolver.MUMPS">
            <summary>
            Using <see cref="T:ilPSP.LinSolvers.MUMPS.MUMPSSolver"/>.
            </summary>
        </member>
        <member name="F:BoSSS.Solution.AdvancedSolvers.DirectSolver._whichSolver.Lapack">
            <summary>
            Conversion to dense matrix, solution 
            via LU-decomposition from LAPACK, see also <see cref="M:ilPSP.IMatrixExtensions.Solve``2(``0,``1)"/>.
            Only suitable for small systems (less than 10000 DOF).
            </summary>
        </member>
        <member name="F:BoSSS.Solution.AdvancedSolvers.DirectSolver._whichSolver.Matlab">
            <summary>
            MATLAB 'backslash' solver, see <see cref="M:ilPSP.Connectors.Matlab.Extensions.SolveMATLAB``2(ilPSP.LinSolvers.IMutableMatrixEx,``0,``1,System.String)"/> 
            </summary>
        </member>
        <member name="M:BoSSS.Solution.AdvancedSolvers.DirectSolver.Solve``2(``0,``1)">
            <summary>
            %
            </summary>
        </member>
        <member name="P:BoSSS.Solution.AdvancedSolvers.DirectSolver.ActivateCaching">
            <summary>
            Instruction for delayed caching of the factorization of block solver.
            Useful if memory peaks in linear solver tend to burst the memory.
            - 1st int: number of iterations
            - 2nd int: multigrid level
            </summary>
        </member>
        <member name="M:BoSSS.Solution.AdvancedSolvers.DirectSolver.Dispose">
            <summary>
            Release internal memory
            </summary>
        </member>
        <member name="T:BoSSS.Solution.AdvancedSolvers.ExtensionMethods">
            <summary>
            Collection of various extension methods.
            </summary>
        </member>
        <member name="M:BoSSS.Solution.AdvancedSolvers.ExtensionMethods.UpdateXdgAggregationBasis(BoSSS.Solution.AdvancedSolvers.AggregationGridBasis[][],BoSSS.Foundation.XDG.MultiphaseCellAgglomerator)">
            <summary>
            Updates the XDG component of an aggregation basis according to the new agglomeration.
            </summary>
        </member>
        <member name="T:BoSSS.Solution.AdvancedSolvers.FixpointIterator">
            <summary>
            Fix-point iteration, should have linear convergence.
            </summary>
        </member>
        <member name="M:BoSSS.Solution.AdvancedSolvers.FixpointIterator.#ctor(BoSSS.Solution.AdvancedSolvers.OperatorEvalOrLin,System.Collections.Generic.IEnumerable{BoSSS.Solution.AdvancedSolvers.AggregationGridBasis[]},BoSSS.Solution.AdvancedSolvers.MultigridOperator.ChangeOfBasisConfig[][])">
            <summary>
            
            </summary>
        </member>
        <member name="T:BoSSS.Solution.AdvancedSolvers.FixpointIterator.CoupledConvergenceReached">
            <summary>
            delegate for checking the convergence criteria of the coupled iteration
            </summary>
            <returns></returns>
        </member>
        <member name="T:BoSSS.Solution.AdvancedSolvers.FlexGMRES">
            <summary>
            Flexible GMRES (FGMRES), i.e. GMRES with flexible preconditioner,
            accordting to
            @article{saad_flexible_1993,
                title = {A Flexible Inner-Outer Preconditioned {GMRES} Algorithm},
                volume = {14},
                issn = {1064-8275, 1095-7197},
                url = {http://epubs.siam.org/doi/abs/10.1137/0914028},
                doi = {10.1137/0914028},
                number = {2},
                journal = {{SIAM} Journal on Scientific Computing},
                author = {Saad, Youcef},
                year = {1993},
                pages = {461--469}
            }
            </summary>
        </member>
        <member name="F:BoSSS.Solution.AdvancedSolvers.FlexGMRES.PrecondS">
            <summary>
            preconditioners used 
            </summary>
        </member>
        <member name="P:BoSSS.Solution.AdvancedSolvers.FlexGMRES.TerminationCriterion">
            <summary>
            ~
            </summary>
        </member>
        <member name="M:BoSSS.Solution.AdvancedSolvers.FlexGMRES.#ctor">
            <summary>
            ctor
            </summary>
        </member>
        <member name="F:BoSSS.Solution.AdvancedSolvers.FlexGMRES.MaxKrylovDim">
            <summary>
            Number of solution vectors in the internal Krylov-Space
            </summary>
        </member>
        <member name="M:BoSSS.Solution.AdvancedSolvers.FlexGMRES.Solve``2(``0,``1)">
            <summary>
            ~
            </summary>
        </member>
        <member name="T:BoSSS.Solution.AdvancedSolvers.kcycle">
            <summary>
            Krylov-cycle: solver at coarse level is krylov method with further MG descend/coarse grid as preconditioner.
            inspired by (Notay and Vassilevski, 2008), DOI:http://doi.wiley.com/10.1002/nla.542
            </summary>
        </member>
        <member name="M:BoSSS.Solution.AdvancedSolvers.kcycle.Residual``3(``0,``1,``2)">
            <summary>
            computes the residual on this level.
            </summary>
        </member>
        <member name="M:BoSSS.Solution.AdvancedSolvers.kcycle.Solve``2(``0,``1)">
            <summary>
            the multigrid iterations for a linear problem
            </summary>
            <param name="xl">on input, the initial guess; on exit, the result of the multigrid iteration</param>
            <param name="bl">the right-hand-side of the problem</param>
        </member>
        <member name="P:BoSSS.Solution.AdvancedSolvers.kcycle.ThisLevelIterations">
            <summary>
            %
            </summary>
        </member>
        <member name="T:BoSSS.Solution.AdvancedSolvers.GenericRestriction">
            <summary>
            A generic restriction by one mesh level, at which the <see cref="F:BoSSS.Solution.AdvancedSolvers.GenericRestriction.CoarserLevelSolver"/> is used
            </summary>
        </member>
        <member name="M:BoSSS.Solution.AdvancedSolvers.GenericRestriction.Solve``2(``0,``1)">
            <summary>
            Restriction of <paramref name="X"/> and <paramref name="B"/> to lower level, execution of <see cref="F:BoSSS.Solution.AdvancedSolvers.GenericRestriction.CoarserLevelSolver"/> and prolongation of coarse solution.
            </summary>
        </member>
        <member name="T:BoSSS.Solution.AdvancedSolvers.GridAndDegRestriction">
            <summary>
            Restriction of a <see cref="T:BoSSS.Solution.AdvancedSolvers.IOperatorMappingPair"/> onto a sub-mesh with lower polynomial degree, 
            i.e. this object is not a solver on its own, but it performs the restriction of the operator matrix
            to a certain **subset of cells and modes**.
            - sub-mes restriction and degree restriction can be used independent,
              i.e. it is also possible to use only one of them
            - the solution of the sub-system is performed by <see cref="F:BoSSS.Solution.AdvancedSolvers.GridAndDegRestriction.LowerPSolver"/>
            - the polynomial degree hierarchy is defined by setting <see cref="F:BoSSS.Solution.AdvancedSolvers.GridAndDegRestriction.RestrictedDeg"/>
            - mesh restriction is performed by <see cref="F:BoSSS.Solution.AdvancedSolvers.GridAndDegRestriction.GetCellRestriction"/>
            </summary>
        </member>
        <member name="T:BoSSS.Solution.AdvancedSolvers.GridAndDegRestriction.MgOperatorRestriction">
            <summary>
            Note: at this point, we do not support everything which a <see cref="T:BoSSS.Solution.AdvancedSolvers.SubBlockSelector"/> can support.
            This is, because not all selections, which <see cref="T:BoSSS.Solution.AdvancedSolvers.SubBlockSelector"/> can do are supported by <see cref="T:BoSSS.Solution.AdvancedSolvers.ICoordinateMapping"/> at this point.
            </summary>
        </member>
        <member name="F:BoSSS.Solution.AdvancedSolvers.GridAndDegRestriction.GetCellRestriction">
            <summary>
            Optional restriction to a subset of cells/matrix blocks:
            returns local indices of cells which should be in the selection;
            if null, all cells are selected
            </summary>
        </member>
        <member name="F:BoSSS.Solution.AdvancedSolvers.GridAndDegRestriction.GetExtRows">
            <summary>
            Matrix containing external rows, if <see cref="F:BoSSS.Solution.AdvancedSolvers.GridAndDegRestriction.GetCellRestriction"/> provides external cells;
            these rows would then be copied to this processor
            </summary>
        </member>
        <member name="F:BoSSS.Solution.AdvancedSolvers.GridAndDegRestriction.GetExtMem">
            <summary>
            Memory for external rows, if <see cref="F:BoSSS.Solution.AdvancedSolvers.GridAndDegRestriction.GetCellRestriction"/> provides external cells;
            (see <see cref="P:BoSSS.Solution.AdvancedSolvers.MPIexchange`1.Vector_Ext"/>, <see cref="P:BoSSS.Solution.AdvancedSolvers.MPIexchangeInverse`1.Vector_Ext"/>)
            </summary>
        </member>
        <member name="F:BoSSS.Solution.AdvancedSolvers.GridAndDegRestriction.RestrictToMPIself">
            <summary>
            if true, the nested solver is working serially (only on the respective core), i.e. on the SELF communicator;
            </summary>
        </member>
        <member name="F:BoSSS.Solution.AdvancedSolvers.GridAndDegRestriction.RestrictedDeg">
            <summary>
            DG polynomial degrees in the restricted system
            </summary>
        </member>
        <member name="F:BoSSS.Solution.AdvancedSolvers.GridAndDegRestriction.LowerPSolver">
            <summary>
            solver for the restricted system
            </summary>
        </member>
        <member name="P:BoSSS.Solution.AdvancedSolvers.GridAndDegRestriction.SubsysMatrix">
            <summary>
            matrix of sub-system
            </summary>
        </member>
        <member name="P:BoSSS.Solution.AdvancedSolvers.GridAndDegRestriction.OperatorRestriction">
            <summary>
            Access to sub-system
            </summary>
        </member>
        <member name="T:BoSSS.Solution.AdvancedSolvers.HypreAMR">
            <summary>
            Parallel ILU from HYPRE library
            </summary>
        </member>
        <member name="T:BoSSS.Solution.AdvancedSolvers.ISolverSmootherTemplate">
            <summary>
            The basic interface for a linear solver. 
            </summary>
        </member>
        <member name="M:BoSSS.Solution.AdvancedSolvers.ISolverSmootherTemplate.Init(BoSSS.Solution.AdvancedSolvers.MultigridOperator)">
            <summary>
            Initializes the linear solver.
            </summary>
            <param name="op">
            Provides the matrix for the solver.
            </param>
        </member>
        <member name="M:BoSSS.Solution.AdvancedSolvers.ISolverSmootherTemplate.Solve``2(``0,``1)">
            <summary>
            Call to solver/smoother.
            </summary>
            <param name="X">
            On entry: initial guess for the solution; on exit: approximate solution after applying the solver/smoother.
            </param>
            <param name="B">
            On entry: the right-hand-side of the system.
            </param>
        </member>
        <member name="P:BoSSS.Solution.AdvancedSolvers.ISolverSmootherTemplate.IterationsInNested">
            <summary>
            Total number of iterations (since the last call to <see cref="M:BoSSS.Solution.AdvancedSolvers.ISolverSmootherTemplate.ResetStat"/>) in nested solvers.
            </summary>
        </member>
        <member name="P:BoSSS.Solution.AdvancedSolvers.ISolverSmootherTemplate.ThisLevelIterations">
            <summary>
            Total number of iterations (since the last call to <see cref="M:BoSSS.Solution.AdvancedSolvers.ISolverSmootherTemplate.ResetStat"/>) on the multi-grid level associated with this solver.
            </summary>
        </member>
        <member name="P:BoSSS.Solution.AdvancedSolvers.ISolverSmootherTemplate.Converged">
            <summary>
            True, if the last call to <see cref="M:BoSSS.Solution.AdvancedSolvers.ISolverSmootherTemplate.Solve``2(``0,``1)"/> was successful.
            </summary>
        </member>
        <member name="M:BoSSS.Solution.AdvancedSolvers.ISolverSmootherTemplate.ResetStat">
            <summary>
            Reset solver statistics, i.e. set <see cref="P:BoSSS.Solution.AdvancedSolvers.ISolverSmootherTemplate.IterationsInNested"/>, <see cref="P:BoSSS.Solution.AdvancedSolvers.ISolverSmootherTemplate.ThisLevelIterations"/>, etc. to 0.
            </summary>
        </member>
        <member name="M:BoSSS.Solution.AdvancedSolvers.ISolverSmootherTemplate.UsedMemory">
            <summary>
            Estimate of used memory in bytes
            </summary>
        </member>
        <member name="T:BoSSS.Solution.AdvancedSolvers.IOperatorMappingPair">
            <summary>
            Minimal information which a solver/smoother might require; This is
            - obviously, the matrix <see cref="P:BoSSS.Solution.AdvancedSolvers.IOperatorMappingPair.OperatorMatrix"/>
            - minimal information about the underlying GD discretization, see <see cref="P:BoSSS.Solution.AdvancedSolvers.IOperatorMappingPair.DgMapping"/>
            </summary>
            <remarks>
            Feb22: This was designed in an attempt to make the solvers defined by <see cref="T:BoSSS.Solution.AdvancedSolvers.ISolverSmootherTemplate"/>,
            which always work on the **entire** mesh and system usable on **sub-systems**.
            At this point, the functionality in <see cref="T:BoSSS.Solution.AdvancedSolvers.SubBlockSelector"/> and <see cref="T:BoSSS.Solution.AdvancedSolvers.BlockMask"/> allows
            to extract sub-matrices of the full system matrix. However, it is not possible to apply a <see cref="T:BoSSS.Solution.AdvancedSolvers.ISolverSmootherTemplate"/>
            onto this matrix, since those solvers require a full <see cref="T:BoSSS.Solution.AdvancedSolvers.MultigridOperator"/> 
            to be initialized (<see cref="M:BoSSS.Solution.AdvancedSolvers.ISolverSmootherTemplate.Init(BoSSS.Solution.AdvancedSolvers.MultigridOperator)"/>.
            </remarks>
        </member>
        <member name="P:BoSSS.Solution.AdvancedSolvers.IOperatorMappingPair.OperatorMatrix">
            <summary>
            Returns the Operator matrix on the current multigrid level.
            </summary>
        </member>
        <member name="P:BoSSS.Solution.AdvancedSolvers.IOperatorMappingPair.DgMapping">
            <summary>
            Minimal information about the DG structure behind matrix <see cref="P:BoSSS.Solution.AdvancedSolvers.IOperatorMappingPair.OperatorMatrix"/>
            </summary>
        </member>
        <member name="T:BoSSS.Solution.AdvancedSolvers.ISubsystemSolver">
            <summary>
            Defines a solver which is able to work on sub-system, i.e. some part of the matrix on the full mesh.
            </summary>
        </member>
        <member name="M:BoSSS.Solution.AdvancedSolvers.ISubsystemSolver.Init(BoSSS.Solution.AdvancedSolvers.IOperatorMappingPair)">
            <summary>
            Initializes the linear solver.
            </summary>
            <param name="op">
            Provides the matrix for the solver.
            </param>
        </member>
        <member name="T:BoSSS.Solution.AdvancedSolvers.ISolverFactory">
            <summary>
            
            </summary>
        </member>
        <member name="P:BoSSS.Solution.AdvancedSolvers.ISolverFactory.Name">
            <summary>
            Name/Description of the solver configuration
            </summary>
        </member>
        <member name="P:BoSSS.Solution.AdvancedSolvers.ISolverFactory.Shortname">
            <summary>
            short version of <see cref="P:BoSSS.Solution.AdvancedSolvers.ISolverFactory.Name"/>, e.g. to be used in plots or tables
            </summary>
        </member>
        <member name="M:BoSSS.Solution.AdvancedSolvers.ISolverFactory.CreateInstance(BoSSS.Solution.AdvancedSolvers.MultigridOperator)">
            <summary>
            Creates an Instance of the respective solver
            </summary>
        </member>
        <member name="T:BoSSS.Solution.AdvancedSolvers.IProgrammableTermination">
            <summary>
            For certain solvers, a programmable termination criterion seems handy.
            On the other hand, preconditioners most of the time run on a fixed number of iterations.
            </summary>
        </member>
        <member name="P:BoSSS.Solution.AdvancedSolvers.IProgrammableTermination.TerminationCriterion">
            <summary>
            User-Programmable termination criterion: 
            - 1st argument: iteration index
            - 2nd argument: l2-Norm of residual of initial solution 
            - 3rd argument: l2-Norm of residual of solution in current iteration
            - return value, 1st item: true to continue, false to terminate
            - return value, 2nd item: true for successful convergence (e.g. convergence criterion reached), false for failure (e.g. maximum number of iterations reached)
            </summary>
            <remarks>
            For an example implementation, see
            <see cref="M:BoSSS.Solution.AdvancedSolvers.IterativeSolverConfig.DefaultTermination(System.Int32,System.Double,System.Double)"/>.
            </remarks>
        </member>
        <member name="T:BoSSS.Solution.AdvancedSolvers.ISolverWithCallback">
            <summary>
            Interface for solvers which provide a call-back during the solver-iterations.
            </summary>
        </member>
        <member name="P:BoSSS.Solution.AdvancedSolvers.ISolverWithCallback.IterationCallback">
            <summary>
             - 1st argument: iteration index
             - 2nd argument: current solution
             - 3rd argument: current residual
             - 4th argument: the currently used operator
            </summary>      
        </member>
        <member name="T:BoSSS.Solution.AdvancedSolvers.IterativeSolverConfig">
            <summary>
            Base-class for iterative solver configurations
            </summary>
        </member>
        <member name="F:BoSSS.Solution.AdvancedSolvers.IterativeSolverConfig.MaxSolverIterations">
            <summary>
            If iterative solvers are used, the maximum number of iterations.
            </summary>
        </member>
        <member name="F:BoSSS.Solution.AdvancedSolvers.IterativeSolverConfig.MinSolverIterations">
            <summary>
            If iterative solvers are used, the minimum number of iterations.
            </summary>
        </member>
        <member name="F:BoSSS.Solution.AdvancedSolvers.IterativeSolverConfig.ConvergenceCriterion">
            <summary>
            Convergence criterion for linear solver.
            </summary>
        </member>
        <member name="M:BoSSS.Solution.AdvancedSolvers.IterativeSolverConfig.DefaultTermination(System.Int32,System.Double,System.Double)">
            <summary>
            Termination criterion based on the threshold <see cref="F:BoSSS.Solution.AdvancedSolvers.IterativeSolverConfig.ConvergenceCriterion"/>.
            </summary>
            <returns>
            - 1st item: true: solver should continue; false: terminate;
            - 2nd item: if first item true, either success (true, i.e. solver converged successfully) or fail (false, e.g. reached the <see cref="F:BoSSS.Solution.AdvancedSolvers.IterativeSolverConfig.MaxSolverIterations"/>);
            </returns>
        </member>
        <member name="P:BoSSS.Solution.AdvancedSolvers.IterativeSolverConfig.Name">
            <summary>
            Name/Description of the solver configuration
            </summary>
        </member>
        <member name="P:BoSSS.Solution.AdvancedSolvers.IterativeSolverConfig.Shortname">
            <summary>
            short version of <see cref="P:BoSSS.Solution.AdvancedSolvers.IterativeSolverConfig.Name"/>, e.g. to be used in plots or tables
            </summary>
        </member>
        <member name="M:BoSSS.Solution.AdvancedSolvers.IterativeSolverConfig.CreateInstance(BoSSS.Solution.AdvancedSolvers.MultigridOperator)">
            <summary>
            <see cref="M:BoSSS.Solution.AdvancedSolvers.ISolverFactory.CreateInstance(BoSSS.Solution.AdvancedSolvers.MultigridOperator)"/>
            </summary>
        </member>
        <member name="M:BoSSS.Solution.AdvancedSolvers.IterativeSolverConfig.Equals(BoSSS.Solution.AdvancedSolvers.ISolverFactory)">
            <summary>
            
            </summary>
        </member>
        <member name="M:BoSSS.Solution.AdvancedSolvers.IterativeSolverConfig.Equals(System.Object)">
            <summary>
            
            </summary>
        </member>
        <member name="F:BoSSS.Solution.AdvancedSolvers.Jacobi.omega">
            <summary>
            Jacobi-Damping
            </summary>
        </member>
        <member name="M:BoSSS.Solution.AdvancedSolvers.Jacobi.Solve``2(``0,``1)">
            <summary>
            Jacobi iteration
            </summary>
        </member>
        <member name="T:BoSSS.Solution.AdvancedSolvers.LevelPmg">
            <summary>
            p-Multigrid on a single grid level
            </summary>
        </member>
        <member name="T:BoSSS.Solution.AdvancedSolvers.LevelPmg.Config">
            <summary>
            Configuration
            </summary>
        </member>
        <member name="F:BoSSS.Solution.AdvancedSolvers.LevelPmg.Config.UseDiagonalPmg">
            <summary>
            If true, the high order system is solved cell-by-cell (i.e. a Block-Jacobi)
            </summary>
        </member>
        <member name="F:BoSSS.Solution.AdvancedSolvers.LevelPmg.Config.UseHiOrderSmoothing">
            <summary>
            If true, cell-local solvers will be used to approximate a solution to high-order modes
            </summary>
        </member>
        <member name="F:BoSSS.Solution.AdvancedSolvers.LevelPmg.Config.OrderOfCoarseSystem">
            <summary>
            DG degree at low order blocks. This degree is the border, which divides into low order and high order blocks
            </summary>
        </member>
        <member name="F:BoSSS.Solution.AdvancedSolvers.LevelPmg.Config.FullSolveOfCutcells">
            <summary>
            If true blocks/cells containing more than one species are completely assigned to low order block solver.
            This hopefully is better than the default approach
            </summary>
        </member>
        <member name="M:BoSSS.Solution.AdvancedSolvers.LevelPmg.Config.CreateInstance(BoSSS.Solution.AdvancedSolvers.MultigridOperator)">
            <summary>
            
            </summary>
        </member>
        <member name="M:BoSSS.Solution.AdvancedSolvers.LevelPmg.Config.Equals(BoSSS.Solution.AdvancedSolvers.ISolverFactory)">
            <summary>
            
            </summary>
        </member>
        <member name="M:BoSSS.Solution.AdvancedSolvers.LevelPmg.Config.Equals(System.Object)">
            <summary>
            
            </summary>
        </member>
        <member name="P:BoSSS.Solution.AdvancedSolvers.LevelPmg.config">
            <summary>
            configuration
            </summary>
        </member>
        <member name="M:BoSSS.Solution.AdvancedSolvers.LevelPmg.#ctor">
            <summary>
            ctor
            </summary>
        </member>
        <member name="P:BoSSS.Solution.AdvancedSolvers.LevelPmg.TerminationCriterion">
            <summary>
            User-Programmable termination criterion: 
            - 1st argument: iteration index
            - 2nd argument: l2-Norm of residual of initial solution 
            - 3rd argument: l2-Norm of residual of solution in current iteration
            - return value, 1st item: true to continue, false to terminate
            - return value, 2nd item: true for successful convergence (e.g. convergence criterion reached), false for failure (e.g. maximum number of iterations reached)
            </summary>
        </member>
        <member name="P:BoSSS.Solution.AdvancedSolvers.LevelPmg.IterationsInNested">
            <summary>
            always 0, because there is no nested solver
            </summary>
        </member>
        <member name="P:BoSSS.Solution.AdvancedSolvers.LevelPmg.ThisLevelIterations">
            <summary>
            ~
            </summary>
        </member>
        <member name="P:BoSSS.Solution.AdvancedSolvers.LevelPmg.Converged">
            <summary>
            ~
            </summary>
        </member>
        <member name="F:BoSSS.Solution.AdvancedSolvers.LevelPmg.HighOrderBlocks_LU">
            <summary>
            - 1st index: cell
            </summary>
        </member>
        <member name="M:BoSSS.Solution.AdvancedSolvers.LevelPmg.InitImpl(BoSSS.Solution.AdvancedSolvers.IOperatorMappingPair)">
            <summary>
            
            </summary>
        </member>
        <member name="F:BoSSS.Solution.AdvancedSolvers.LevelPmg.lowSolver">
            <summary>
            Solver of low order system.
            The low order system is defined by <see cref="F:BoSSS.Solution.AdvancedSolvers.LevelPmg.Config.OrderOfCoarseSystem"/>
            </summary>
        </member>
        <member name="F:BoSSS.Solution.AdvancedSolvers.LevelPmg.hiSolver">
            <summary>
            experimental, used if <see cref="F:BoSSS.Solution.AdvancedSolvers.LevelPmg.Config.UseDiagonalPmg"/> is not set.
            Then low order and high order blocks are both solved by direct solver.
            </summary>
        </member>
        <member name="M:BoSSS.Solution.AdvancedSolvers.LevelPmg.ResetStat">
            <summary>
            ~
            </summary>
        </member>
        <member name="M:BoSSS.Solution.AdvancedSolvers.LevelPmg.CoarseSolve(System.Double[],System.Double[])">
            <summary>
            Computes the coarse-grid correction
            </summary>
            <param name="x_out">output: coarse level solution, prolongated to fine level</param>
            <param name="in_rhs">input: RHS on fine level</param>
        </member>
        <member name="M:BoSSS.Solution.AdvancedSolvers.LevelPmg.FineSolve(System.Double[],System.Double[])">
            <summary>
            smoothing/solving on high level
            </summary>
        </member>
        <member name="M:BoSSS.Solution.AdvancedSolvers.LevelPmg.MGfull(System.Int32,System.Double[],System.Double[])">
            <summary>
            Algorithm 3 in:
            
            p-Multigrid matrix-free discontinuous Galerkin solution strategies for the under-resolved simulation of incompressible turbulent flows
            M. Franciolini, L. Botti, A. Colombo, A. Crivellini
            </summary>
        </member>
        <member name="M:BoSSS.Solution.AdvancedSolvers.LevelPmg.MGv(System.Int32,System.Double[],System.Double[])">
            <summary>
            Algorithm 2 in:
            
            p-Multigrid matrix-free discontinuous Galerkin solution strategies for the under-resolved simulation of incompressible turbulent flows
            M. Franciolini, L. Botti, A. Colombo, A. Crivellini
            </summary>
        </member>
        <member name="M:BoSSS.Solution.AdvancedSolvers.LevelPmg.Solve``2(``0,``1)">
            <summary>
            ~
            </summary>
        </member>
        <member name="P:BoSSS.Solution.AdvancedSolvers.LevelPmg.IterationCallback">
            <summary>
            Called upon each iteration
            </summary>
        </member>
        <member name="M:BoSSS.Solution.AdvancedSolvers.LevelPmg.Dispose">
            <summary>
            
            </summary>
        </member>
        <member name="M:BoSSS.Solution.AdvancedSolvers.LevelPmg.UsedMemory">
            <summary>
            
            </summary>
        </member>
        <member name="M:BoSSS.Solution.AdvancedSolvers.MGopExtensions.ProlongateSolToDg``1(BoSSS.Solution.AdvancedSolvers.MultigridOperator,``0,System.String)">
            <summary>
            Converts a solution vector from some multigrid level into DG fields-
            </summary>
        </member>
        <member name="M:BoSSS.Solution.AdvancedSolvers.MGopExtensions.ProlongateRhsToDg``1(BoSSS.Solution.AdvancedSolvers.MultigridOperator,``0,System.String)">
            <summary>
            Converts a RHS/residual vector from some multigrid level into DG fields-
            </summary>
        </member>
        <member name="T:BoSSS.Solution.AdvancedSolvers.MGViz">
            <summary>
            Utility class for visualization of intermediate results.
            </summary>
        </member>
        <member name="T:BoSSS.Solution.AdvancedSolvers.MonkeySolver">
            <summary>
            Wrapper around the monkey solver (supports GPU acceleration).
            </summary>
        </member>
        <member name="T:BoSSS.Solution.AdvancedSolvers.MonkeySolver._whichSolver">
            <summary>
            
            </summary>
        </member>
        <member name="F:BoSSS.Solution.AdvancedSolvers.MonkeySolver._whichSolver.CG">
            <summary>
            conjugate gradient solver, see <see cref="T:ilPSP.LinSolvers.monkey.CG"/>
            </summary>
        </member>
        <member name="F:BoSSS.Solution.AdvancedSolvers.MonkeySolver._whichSolver.PCG">
            <summary>
            preconditioned conjugate gradient solver, see <see cref="T:ilPSP.LinSolvers.monkey.PCG"/>
            </summary>
        </member>
        <member name="T:BoSSS.Solution.AdvancedSolvers.MonkeySolver.Config">
            <summary>
            Configurable factory for the Money solver
            </summary>
        </member>
        <member name="F:BoSSS.Solution.AdvancedSolvers.MonkeySolver.Config.WhichSolver">
            <summary>
            Switch between CG/PCG
            </summary>
        </member>
        <member name="P:BoSSS.Solution.AdvancedSolvers.MonkeySolver.config">
            <summary>
            Solver configuration
            </summary>
        </member>
        <member name="M:BoSSS.Solution.AdvancedSolvers.MonkeySolver.Solve``2(``0,``1)">
            <summary>
            %
            </summary>
        </member>
        <member name="P:BoSSS.Solution.AdvancedSolvers.MonkeySolver.IterationsInNested">
            <summary>
            %
            </summary>
        </member>
        <member name="P:BoSSS.Solution.AdvancedSolvers.MonkeySolver.ThisLevelIterations">
            <summary>
            
            </summary>
        </member>
        <member name="P:BoSSS.Solution.AdvancedSolvers.MonkeySolver.Converged">
            <summary>
            
            </summary>
        </member>
        <member name="M:BoSSS.Solution.AdvancedSolvers.MonkeySolver.ResetStat">
            <summary>
            
            </summary>
        </member>
        <member name="M:BoSSS.Solution.AdvancedSolvers.MonkeySolver.Clone">
            <summary>
            
            </summary>
        </member>
        <member name="M:BoSSS.Solution.AdvancedSolvers.MonkeySolver.Dispose">
            <summary>
            Release internal memory
            </summary>
        </member>
        <member name="T:BoSSS.Solution.AdvancedSolvers.MPIexchange`1">
            <summary>
            Parallelization/MPI data exchange for a vector.
            </summary>
            <typeparam name="T">vector/array</typeparam>
        </member>
        <member name="P:BoSSS.Solution.AdvancedSolvers.MPIexchange`1.Vector">
            <summary>
            Locally stored data, handed over by the constructor. 
            </summary>
        </member>
        <member name="P:BoSSS.Solution.AdvancedSolvers.MPIexchange`1.Vector_Ext">
            <summary>
            Data associated with external cells.
            </summary>
        </member>
        <member name="M:BoSSS.Solution.AdvancedSolvers.MPIexchange`1.#ctor(BoSSS.Solution.AdvancedSolvers.MultigridMapping,`0)">
            <summary>
            ctor.
            </summary>
        </member>
        <member name="F:BoSSS.Solution.AdvancedSolvers.MPIexchange`1.SendBuffers">
            <summary>
            Internal send buffers
            - 1st index: correlates with receiver process, as in <see cref="P:BoSSS.Foundation.Grid.IParallelization.ProcessesToSendTo"/>.
            - 2nd index: determined by the send list, see <see cref="P:BoSSS.Foundation.Grid.IParallelization.SendCommLists"/>
            </summary>
        </member>
        <member name="M:BoSSS.Solution.AdvancedSolvers.MPIexchange`1.TransceiveStartImReturn">
            <summary>
            initiates the send/receive - processes and returns immediately;
            Every call of this method must be matched by a later call to <see cref="M:BoSSS.Solution.AdvancedSolvers.MPIexchange`1.TransceiveFinish(System.Double)"/>;
            </summary>
        </member>
        <member name="F:BoSSS.Solution.AdvancedSolvers.MPIexchange`1.RcvBufferPin">
            <summary>
            GC pinning of <see cref="F:BoSSS.Solution.AdvancedSolvers.MPIexchange`1.RcvBuffer"/>, index correlates with 1st index of <see cref="F:BoSSS.Solution.AdvancedSolvers.MPIexchange`1.RcvBuffer"/>
            </summary>
        </member>
        <member name="M:BoSSS.Solution.AdvancedSolvers.MPIexchange`1.TransceiveFinish(System.Double)">
            <summary>
            Blocks until the send/receive - processes started by <see cref="M:BoSSS.Solution.AdvancedSolvers.MPIexchange`1.TransceiveStartImReturn"/> are complete and returns;
            The received data is **accumulated** in <see cref="P:BoSSS.Solution.AdvancedSolvers.MPIexchange`1.Vector_Ext"/>.
            </summary>
            <param name="beta">
            Pre-scaling of <see cref="P:BoSSS.Solution.AdvancedSolvers.MPIexchange`1.Vector_Ext"/>
            </param>
        </member>
        <member name="T:BoSSS.Solution.AdvancedSolvers.MPIexchangeInverse`1">
            <summary>
            Parallelization/MPI data exchange for a vector, in *the inverse direction*, i.e. data stored in external cells 
            is accumulated in locally owned cells of other processors.
            </summary>
            <typeparam name="T">vector/array</typeparam>
        </member>
        <member name="P:BoSSS.Solution.AdvancedSolvers.MPIexchangeInverse`1.Vector">
            <summary>
            Locally stored data, handed over by the constructor. 
            </summary>
        </member>
        <member name="P:BoSSS.Solution.AdvancedSolvers.MPIexchangeInverse`1.Vector_Ext">
            <summary>
            Data associated with external cells.
            </summary>
        </member>
        <member name="M:BoSSS.Solution.AdvancedSolvers.MPIexchangeInverse`1.#ctor(BoSSS.Solution.AdvancedSolvers.MultigridMapping,`0)">
            <summary>
            ctor.
            </summary>
        </member>
        <member name="F:BoSSS.Solution.AdvancedSolvers.MPIexchangeInverse`1.SendBuffers">
            <summary>
            Internal send buffers
            - 1st index: correlates with receiver process, as in <see cref="P:BoSSS.Foundation.Grid.IParallelization.ProcessesToReceiveFrom"/>.
            - 2nd index: determined by the sequence of external cells
            </summary>
        </member>
        <member name="M:BoSSS.Solution.AdvancedSolvers.MPIexchangeInverse`1.TransceiveStartImReturn">
            <summary>
            initiates the send/receive - processes and returns immediately;
            Every call of this method must be matched by a later call to <see cref="M:BoSSS.Solution.AdvancedSolvers.MPIexchangeInverse`1.TransceiveFinish(System.Double)"/>;
            </summary>
        </member>
        <member name="F:BoSSS.Solution.AdvancedSolvers.MPIexchangeInverse`1.RcvBufferPin">
            <summary>
            GC pinning of <see cref="F:BoSSS.Solution.AdvancedSolvers.MPIexchangeInverse`1.RcvBuffer"/>, index correlates with 1st index of <see cref="F:BoSSS.Solution.AdvancedSolvers.MPIexchangeInverse`1.RcvBuffer"/>
            </summary>
        </member>
        <member name="M:BoSSS.Solution.AdvancedSolvers.MPIexchangeInverse`1.TransceiveFinish(System.Double)">
            <summary>
            Blocks until the send/receive - processes started by <see cref="M:BoSSS.Solution.AdvancedSolvers.MPIexchangeInverse`1.TransceiveStartImReturn"/> are complete and returns;
            The received data is **accumulated** in <see cref="P:BoSSS.Solution.AdvancedSolvers.MPIexchangeInverse`1.Vector"/>.
            </summary>
            <param name="beta">
            Pre-scaling of <see cref="P:BoSSS.Solution.AdvancedSolvers.MPIexchangeInverse`1.Vector_Ext"/>
            </param>
        </member>
        <member name="T:BoSSS.Solution.AdvancedSolvers.MultigridMapping">
            <summary>
            For each aggregation grid level, this mapping defines a bijection between variable index,
            DG mode and aggregation cell index and a unique index.
            </summary>
        </member>
        <member name="P:BoSSS.Solution.AdvancedSolvers.MultigridMapping.GridData">
            <summary>
            Base grid on which the problem is defined.
            </summary>
        </member>
        <member name="P:BoSSS.Solution.AdvancedSolvers.MultigridMapping.ProblemMapping">
            <summary>
            Coordinate mapping on the original grid.
            </summary>
        </member>
        <member name="P:BoSSS.Solution.AdvancedSolvers.MultigridMapping.AggBasis">
            <summary>
            Aggregation basis on this level, for each variable.
            </summary>
        </member>
        <member name="P:BoSSS.Solution.AdvancedSolvers.MultigridMapping.NoOfVariables">
            <summary>
            Number of variables
            </summary>
        </member>
        <member name="P:BoSSS.Solution.AdvancedSolvers.MultigridMapping.AggGrid">
            <summary>
            aggregation grid on this level
            </summary>
        </member>
        <member name="P:BoSSS.Solution.AdvancedSolvers.MultigridMapping.LocalLength">
            <summary>
            Number of DOF's stored on this  MPI process
            </summary>
        </member>
        <member name="P:BoSSS.Solution.AdvancedSolvers.MultigridMapping.Partitioning">
            <summary>
            Partitioning of the vector among MPI processes.
            </summary>
        </member>
        <member name="P:BoSSS.Solution.AdvancedSolvers.MultigridMapping.TotalLength">
            <summary>
            Total number of DOF's over all MPI processes.
            </summary>
        </member>
        <member name="P:BoSSS.Solution.AdvancedSolvers.MultigridMapping.DgDegree">
            <summary>
            For each DG basis in the <see cref="P:BoSSS.Solution.AdvancedSolvers.MultigridMapping.ProblemMapping"/>, the DG polynomial degree
            which is used on this level.
            </summary>
        </member>
        <member name="M:BoSSS.Solution.AdvancedSolvers.MultigridMapping.#ctor(BoSSS.Foundation.UnsetteledCoordinateMapping,BoSSS.Solution.AdvancedSolvers.AggregationGridBasis[],System.Int32[])">
            <summary>
            Constructor
            </summary>
            <param name="__ProblemMapping">
            Mapping of original problem, equal to <see cref="P:BoSSS.Solution.AdvancedSolvers.MultigridMapping.ProblemMapping"/>.
            </param>
            <param name="__aggGrdB">
            Sequence of aggregation grid DG basis objects, correlates to original mapping
            </param>
            <param name="DgDegrees"></param>
        </member>
        <member name="F:BoSSS.Solution.AdvancedSolvers.MultigridMapping.m_i0">
            <summary>
            For each aggregation cell, the local vector index of the first DG coordinate in this cell.
            - index: local aggregation cell index.
            </summary>
        </member>
        <member name="F:BoSSS.Solution.AdvancedSolvers.MultigridMapping.m_i0_ExtGlob">
            <summary>
            For each external aggregation cell, the global vector index of the first DG coordinate in this cell.
            - index: external aggregation cell index, minus local number of aggregation cells
            </summary>
        </member>
        <member name="M:BoSSS.Solution.AdvancedSolvers.MultigridMapping.GetLengthForVar(System.Int32,System.Int32)">
            <summary>
            Number of degrees-of-freedom in cell <paramref name="jCell"/> , for the <paramref name="iVar"/>-th variable.
            </summary>
        </member>
        <member name="P:BoSSS.Solution.AdvancedSolvers.MultigridMapping.MaximalLength">
            <summary>
            For this mapping, the maximum DOF used per cell over all cells.
            </summary>
        </member>
        <member name="P:BoSSS.Solution.AdvancedSolvers.MultigridMapping.MinimalLength">
            <summary>
            For this mapping, the minimum DOF used per cell over all cells.
            </summary>
        </member>
        <member name="P:BoSSS.Solution.AdvancedSolvers.MultigridMapping.FirstBlock">
            <summary>
            Gets the first block on this process
            </summary>
        </member>
        <member name="P:BoSSS.Solution.AdvancedSolvers.MultigridMapping.AllBlockSizesEqual">
            <summary>
            Tests, if Max and Minblocksize are equal
            </summary>
        </member>
        <member name="M:BoSSS.Solution.AdvancedSolvers.MultigridMapping.GetProlongationOperator(BoSSS.Solution.AdvancedSolvers.MultigridMapping)">
            <summary>
            Prolongation/Injection operator to finer grid level.
            </summary>
        </member>
        <member name="M:BoSSS.Solution.AdvancedSolvers.MultigridMapping.FromOtherLevelMatrix(BoSSS.Solution.AdvancedSolvers.MultigridMapping)">
            <summary>
            Prolongation or Restriction from *any* other level to this level.
            </summary>
            <param name="otherLevel">
            Other level, from which one wants to prolongate/restrict.
            </param>
            <returns>
            A matrix, where 
            - row correspond to this mapping
            - columns correspond to <paramref name="otherLevel"/>
            If the other level is coarser, this is a prolongation; if the other level is finer, it is the restriction in the L2-sense,
            for standard DG; for XDG, in some other norm  determined by the cut-cell shape.
            </returns>
        </member>
        <member name="M:BoSSS.Solution.AdvancedSolvers.MultigridMapping.GetSubvectorIndices(System.Int32[])">
            <summary>
            Returns global unique indices which correlate to a certain sub-set of this mapping's 
            basises (<see cref="P:BoSSS.Foundation.UnsetteledCoordinateMapping.BasisS"/>).
            </summary>
            <param name="Fields">
            Indices into <see cref="P:BoSSS.Solution.AdvancedSolvers.MultigridMapping.AggBasis"/>
            </param>
        </member>
        <member name="M:BoSSS.Solution.AdvancedSolvers.MultigridMapping.GetSubvectorIndices_Ext(System.Int32[])">
            <summary>
            Gets index vecor of all ghost cells available on this proc
            </summary>
            <param name="Fields"></param>
            <returns></returns>
        </member>
        <member name="M:BoSSS.Solution.AdvancedSolvers.MultigridMapping.GetSubvectorIndices(BoSSS.Foundation.XDG.SpeciesId,System.Int32[])">
            <summary>
            Returns global unique indices which correlate to a certain species and basises.
            </summary>
            <param name="Fields">
            Indices into <see cref="P:BoSSS.Solution.AdvancedSolvers.MultigridMapping.AggBasis"/>
            </param>
            <param name="Species">
            </param>
            <returns>a list of global (over all MPI processes) unique indices.</returns>
        </member>
        <member name="M:BoSSS.Solution.AdvancedSolvers.MultigridMapping.GetLength(System.Int32)">
            <summary>
            Number of degrees-of-freedom, for all variables, in cell <paramref name="jCell"/>.
            </summary>
            <param name="jCell">Local cell index.</param>
        </member>
        <member name="P:BoSSS.Solution.AdvancedSolvers.MultigridMapping.UsedSpecies">
            <summary>
            All used XDG species.
            Index: enumeration over species.
            </summary>
        </member>
        <member name="F:BoSSS.Solution.AdvancedSolvers.MultigridOperator.m_ReferenceCell">
            <summary>
            (MPI) global index of cell in which the reference point is located
            </summary>
        </member>
        <member name="P:BoSSS.Solution.AdvancedSolvers.MultigridOperator.ReferenceCell">
            <summary>
            (MPI) global index of cell in which the reference point for floating/free-mean-value solutions (<see cref="P:BoSSS.Foundation.ISpatialOperator.FreeMeanValue"/>) is located
            </summary>
        </member>
        <member name="P:BoSSS.Solution.AdvancedSolvers.MultigridOperator.ReferenceCell_local">
            <summary>
            - on owner process: <see cref="P:BoSSS.Solution.AdvancedSolvers.MultigridOperator.ReferenceCell"/> in local coordinates
            - negative otherwise
            </summary>
        </member>
        <member name="F:BoSSS.Solution.AdvancedSolvers.MultigridOperator.m_ReferenceIndices">
            <summary>
            Global Indices into <see cref="P:BoSSS.Solution.AdvancedSolvers.MultigridOperator.BaseGridProblemMapping"/>
            </summary>
        </member>
        <member name="M:BoSSS.Solution.AdvancedSolvers.MultigridOperator.SetPressureReferencePointRHS``1(``0)">
            <summary>
            modifies a right-hand-side <paramref name="rhs"/>
            in order to fix the pressure at some reference point
            </summary>
        </member>
        <member name="M:BoSSS.Solution.AdvancedSolvers.MultigridOperator.SetPressureReferencePointMTX(ilPSP.LinSolvers.IMutableMatrixEx)">
            <summary>
            modifies a matrix 
            in order to fix the pressure at some reference point
            </summary>
        </member>
        <member name="P:BoSSS.Solution.AdvancedSolvers.MultigridOperator.AbstractOperator">
            <summary>
            DG operatior which is the foundation of this linearization
            </summary>
        </member>
        <member name="P:BoSSS.Solution.AdvancedSolvers.MultigridOperator.DGpolynomialDegreeHierarchy">
            <summary>
            hierarchy of polynomial degrees, for p-multigrid variables, for domain/codomain variables 
            </summary>
        </member>
        <member name="P:BoSSS.Solution.AdvancedSolvers.MultigridOperator.FreeMeanValue">
            <summary>
            pass-through from <see cref="P:BoSSS.Foundation.ISpatialOperator.FreeMeanValue"/>
            </summary>
        </member>
        <member name="M:BoSSS.Solution.AdvancedSolvers.MultigridOperator.#ctor(System.Collections.Generic.IEnumerable{BoSSS.Solution.AdvancedSolvers.AggregationGridBasis[]},BoSSS.Foundation.UnsetteledCoordinateMapping,ilPSP.LinSolvers.BlockMsrMatrix,ilPSP.LinSolvers.BlockMsrMatrix,System.Collections.Generic.IEnumerable{BoSSS.Solution.AdvancedSolvers.MultigridOperator.ChangeOfBasisConfig[]},BoSSS.Foundation.ISpatialOperator)">
            <summary>
            Recursive constructor, i.e. constructs operators on all multigrid levels which are provided by <paramref name="basisSeq"/>.
            </summary>
            <param name="basisSeq"></param>
            <param name="_ProblemMapping">
            DG coordinate mapping on the original grid, see <see cref="P:BoSSS.Solution.AdvancedSolvers.MultigridOperator.BaseGridProblemMapping"/>.
            </param>
            <param name="OperatorMatrix">
            Operator Matrix, aka. Jacobian Matrix,
            agglomeration (if applicable) should already be applied.
            </param>
            <param name="MassMatrix">
            Mass matrix on the original grid. If null, the identity matrix is assumed,
            agglomeration (if applicable) should already be applied.
            </param>
            <param name="cobc">
            Configuration of the cell-wise, explicit block-preconditioning for each multigrid level.
            (Remark: this kind of preconditioning is mathematically equivalent to a change of the DG resp. XDG basis.)
            </param>
            <param name="__AbstractOperator">
            information such as <see cref="P:BoSSS.Foundation.ISpatialOperator.FreeMeanValue"/>,...
            </param>
        </member>
        <member name="M:BoSSS.Solution.AdvancedSolvers.MultigridOperator.Setup">
            <summary>
            deferred initialization of matrices; only executed if an actual matrix is requested.
            </summary>
        </member>
        <member name="M:BoSSS.Solution.AdvancedSolvers.MultigridOperator.Restrict``2(``0,``1)">
            <summary>
            Restricts a right-hand-side or solution vector <paramref name="IN_fine"/> 
            from the finer multi-grid level (see <see cref="P:BoSSS.Solution.AdvancedSolvers.MultigridOperator.FinerLevel"/>)
            to this multi-grid level.
            </summary>
            <param name="IN_fine">Input: vector on finer level.</param>
            <param name="OUT_coarse">Output: vector on this level, i.e. the coarser level.</param>
        </member>
        <member name="M:BoSSS.Solution.AdvancedSolvers.MultigridOperator.Prolongate``2(System.Double,``0,System.Double,``1)">
            <summary>
            Prolongates a solution vector <paramref name="IN_coarse"/> from the this multi-grid level 
            to the finer multigrid level (see <see cref="P:BoSSS.Solution.AdvancedSolvers.MultigridOperator.FinerLevel"/>).
            </summary>
            <param name="OUT_fine">Input/Output: accumulation vector on finer level</param>
            <param name="IN_coarse">Input: vector on this level, i.e. the coarser level.</param>
            <param name="beta">
            scaling of the accumulation vector (see remarks).
            </param>
            <param name="alpha">
            scaling applied to prolongated vector (see remarks).
            </param>
            <remarks>
            On exit,
            <paramref name="OUT_fine"/> = <paramref name="OUT_fine"/>*<paramref name="beta"/> + Pr(<paramref name="IN_coarse"/>)*<paramref name="alpha"/>.
            </remarks>
        </member>
        <member name="P:BoSSS.Solution.AdvancedSolvers.MultigridOperator.LevelIndex">
            <summary>
            Returns the index of this multigrid level. Smaller indices correspond to finer grids.
            </summary>
        </member>
        <member name="P:BoSSS.Solution.AdvancedSolvers.MultigridOperator.NoOfLevels">
            <summary>
            Number of multigrid levels available, including the current level
            </summary>
        </member>
        <member name="F:BoSSS.Solution.AdvancedSolvers.MultigridOperator.IndexIntoProblemMapping_Local">
            <summary>
            only used on top level:
            mapping: 'multigrid mapping index' --> 'full problem index'
             - index: compressed index at this multigrid level
             - content: index into <see cref="P:BoSSS.Solution.AdvancedSolvers.MultigridOperator.BaseGridProblemMapping"/> (local)
             Note: this list is not necessarily ascending, i.e. the order of species might get flipped in the multigrid operator
            </summary>
        </member>
        <member name="F:BoSSS.Solution.AdvancedSolvers.MultigridOperator.IndexIntoProblemMapping_Global">
            <summary>
            only used on top level:
            mapping: 'multigrid mapping index' --> 'full problem index'
             - index: compressed index at this multigrid level
             - content: index into <see cref="P:BoSSS.Solution.AdvancedSolvers.MultigridOperator.BaseGridProblemMapping"/> (global)
             Note: this list is not necessarily ascending, i.e. the order of species might get flipped in the multigrid operator
            </summary>
        </member>
        <member name="P:BoSSS.Solution.AdvancedSolvers.MultigridOperator.Mapping">
            <summary>
            DG coordinate mapping which corresponds to this mesh level, resp. operator matrix (<see cref="P:BoSSS.Solution.AdvancedSolvers.MultigridOperator.OperatorMatrix"/>, <see cref="P:BoSSS.Solution.AdvancedSolvers.MultigridOperator.MassMatrix"/>).
            </summary>
        </member>
        <member name="P:BoSSS.Solution.AdvancedSolvers.MultigridOperator.BaseGridProblemMapping">
            <summary>
            DG coordinate mapping on the original grid/mesh.
            </summary>
        </member>
        <member name="P:BoSSS.Solution.AdvancedSolvers.MultigridOperator.GridData">
            <summary>
            Grid/mesh on which this operator is defined.
            </summary>
        </member>
        <member name="P:BoSSS.Solution.AdvancedSolvers.MultigridOperator.FinerLevel">
            <summary>
            Pointer to operator on finer level.
            </summary>
        </member>
        <member name="P:BoSSS.Solution.AdvancedSolvers.MultigridOperator.FinestLevel">
            <summary>
            Pointer to operator on finest level.
            </summary>
        </member>
        <member name="M:BoSSS.Solution.AdvancedSolvers.MultigridOperator.GetLevel(System.Int32)">
            <summary>
            Returns a multigrid operator at a specifiv level index
            </summary>
        </member>
        <member name="P:BoSSS.Solution.AdvancedSolvers.MultigridOperator.CoarserLevel">
            <summary>
            Pointer to operator on coarser level.
            </summary>
        </member>
        <member name="P:BoSSS.Solution.AdvancedSolvers.MultigridOperator.UsedMemory">
            <summary>
            Number of Bytes used
            </summary>
        </member>
        <member name="M:BoSSS.Solution.AdvancedSolvers.MultigridOperator.GetMemoryInfo(System.Int64@,System.Int64@)">
            <summary>
            Returns the amount of allocated/reserved and actually used memory in this level and coarser levels
            </summary>
        </member>
        <member name="P:BoSSS.Solution.AdvancedSolvers.MultigridOperator.OperatorMatrix">
            <summary>
            Returns the Operator matrix on the current multigrid level.
            </summary>
        </member>
        <member name="P:BoSSS.Solution.AdvancedSolvers.MultigridOperator.MassMatrix">
            <summary>
            Returns the mass matrix on this multigrid level;
            an identity matrix is encoded as null.
            </summary>
        </member>
        <member name="M:BoSSS.Solution.AdvancedSolvers.MultigridOperator.UseSolver``2(BoSSS.Solution.AdvancedSolvers.ISolverSmootherTemplate,``0,``1,System.Boolean)">
            <summary>
            Uses the linear solver <paramref name="solver"/> to solve the system; this includes:
            - transformation of the <paramref name="IN_RHS"/> into the multigrid space, 
            - solving in the multigrid space
            - transformation of the solution back to the <see cref="P:BoSSS.Solution.AdvancedSolvers.MultigridOperator.BaseGridProblemMapping"/>, <paramref name="INOUT_X"/> as an output.
            </summary>
            <param name="solver"></param>
            <param name="INOUT_X">
            - in output: an optional guess for the solution
            - on exit: (hopefully) the solution to the linear problem
            </param>
            <param name="IN_RHS">
            input: right-hand-side of the linear problem
            </param>
            <param name="UseGuess">
            - true: use <paramref name="INOUT_X"/> on entry as an initial guess
            </param>
        </member>
        <member name="M:BoSSS.Solution.AdvancedSolvers.MultigridOperator.ComputeResidual``3(``2,``0,``1)">
            <summary>
            Computes the residual for a given solution approximation
            </summary>
            <param name="IN_X">
            an approximate solution
            </param>
            <param name="IN_RHS">
            right-hand-side of the linear problem
            </param>
            <param name="OUT_Resi">
            On output, 
            </param>
        </member>
        <member name="M:BoSSS.Solution.AdvancedSolvers.MultigridOperator.ComputeResidual``2(``0,``1)">
            <summary>
            Computes the residual for a given solution approximation
            </summary>
            <param name="IN_X">
            an approximate solution
            </param>
            <param name="IN_RHS">
            right-hand-side of the linear problem
            </param>
            <returns>
            the residual vector
            </returns>
        </member>
        <member name="M:BoSSS.Solution.AdvancedSolvers.MultigridOperator.TransformSolInto``2(``0,``1)">
            <summary>
            Transforms a solution from the <see cref="P:BoSSS.Solution.AdvancedSolvers.MultigridOperator.BaseGridProblemMapping"/> into this levels <see cref="P:BoSSS.Solution.AdvancedSolvers.MultigridOperator.Mapping"/>,
            i.e. application of the inverse of right-side preconditioner <see cref="P:BoSSS.Solution.AdvancedSolvers.MultigridOperator.RightChangeOfBasis_Inverse"/>.
            </summary>
            <param name="u_IN">input, length according to <see cref="P:BoSSS.Solution.AdvancedSolvers.MultigridOperator.BaseGridProblemMapping"/></param>
            <param name="v_OUT">output, length according to <see cref="P:BoSSS.Solution.AdvancedSolvers.MultigridOperator.Mapping"/></param>
        </member>
        <member name="M:BoSSS.Solution.AdvancedSolvers.MultigridOperator.TransformRhsInto``2(``0,``1,System.Boolean)">
            <summary>
            Transforms a right-hand-side from the <see cref="P:BoSSS.Solution.AdvancedSolvers.MultigridOperator.BaseGridProblemMapping"/> into this levels <see cref="P:BoSSS.Solution.AdvancedSolvers.MultigridOperator.Mapping"/>,
            i.e. application of the left-side preconditioner <see cref="P:BoSSS.Solution.AdvancedSolvers.MultigridOperator.LeftChangeOfBasis"/>.
            </summary>
            <param name="u_IN">input, length according to <see cref="P:BoSSS.Solution.AdvancedSolvers.MultigridOperator.BaseGridProblemMapping"/></param>
            <param name="v_OUT">output, length according to <see cref="P:BoSSS.Solution.AdvancedSolvers.MultigridOperator.Mapping"/></param>
            <param name="ApplyRef">
            apply additional modification due to free-mean-value fixing (aka. pressure reference point), <see cref="P:BoSSS.Solution.AdvancedSolvers.MultigridOperator.FreeMeanValue"/>
            </param>
        </member>
        <member name="M:BoSSS.Solution.AdvancedSolvers.MultigridOperator.TransformSolFrom``2(``0,``1)">
            <summary>
            transform from this operators domain to the original operator domain (for the trial space)
            </summary>
            <param name="u_Out">output; coordinate vector in the trial space of the original operator, <see cref="P:BoSSS.Solution.AdvancedSolvers.MultigridOperator.BaseGridProblemMapping"/></param>
            <param name="v_In">input: coordinate vector in the trial space of this operator</param>
        </member>
        <member name="M:BoSSS.Solution.AdvancedSolvers.MultigridOperator.TransformRhsFrom``2(``0,``1)">
            <summary>
            transform from this operators domain to the original operator domain (for the test space)
            </summary>
            <param name="u_Out">output; coordinate vector in the test space of the original operator, <see cref="P:BoSSS.Solution.AdvancedSolvers.MultigridOperator.BaseGridProblemMapping"/></param>
            <param name="v_In">input: coordinate vector in the test space of this operator</param>
        </member>
        <member name="T:BoSSS.Solution.AdvancedSolvers.MultigridOperator.ChangeOfBasisConfig">
            <summary>
            configuration item for the change-of-basis in 
            </summary>
        </member>
        <member name="F:BoSSS.Solution.AdvancedSolvers.MultigridOperator.ChangeOfBasisConfig.VarIndex">
            <summary>
            a list of variable indices onto which this configuration item applies.
            </summary>
        </member>
        <member name="F:BoSSS.Solution.AdvancedSolvers.MultigridOperator.ChangeOfBasisConfig.DegreeS">
            <summary>
            DG polynomial degree of respective variables on respective multigrid level
            </summary>
        </member>
        <member name="F:BoSSS.Solution.AdvancedSolvers.MultigridOperator.ChangeOfBasisConfig.mode">
            <summary>
            pre-conditioner mode
            </summary>
        </member>
        <member name="M:BoSSS.Solution.AdvancedSolvers.MultigridOperator.ChangeOfBasisConfig.Clone">
            <summary>
            
            </summary>
        </member>
        <member name="T:BoSSS.Solution.AdvancedSolvers.MultigridOperator.Mode">
            <summary>
            The type of change-of-basis 
            </summary>
        </member>
        <member name="F:BoSSS.Solution.AdvancedSolvers.MultigridOperator.Mode.Eye">
            <summary>
            no change of basis; trial and test function space are 
            kept as they are induced by the restriction operator
            </summary>
        </member>
        <member name="F:BoSSS.Solution.AdvancedSolvers.MultigridOperator.Mode.IdMass">
            <summary>
            Performs a change of the (X)DG basis so that the mass matrix 
            with respect to this basis
            becomes an identity.
            In non-XDG cases, this should be equivalent to <see cref="F:BoSSS.Solution.AdvancedSolvers.MultigridOperator.Mode.Eye"/>.
            </summary>
        </member>
        <member name="F:BoSSS.Solution.AdvancedSolvers.MultigridOperator.Mode.LeftInverse_Mass">
            <summary>
            multiplies with the inverse of the mass matrix from the left
            </summary>
        </member>
        <member name="F:BoSSS.Solution.AdvancedSolvers.MultigridOperator.Mode.DiagBlockEquilib">
            <summary>
            Symmetric equilibration of the diagonal matrix block;
            </summary>
        </member>
        <member name="F:BoSSS.Solution.AdvancedSolvers.MultigridOperator.Mode.SymPart_DiagBlockEquilib">
            <summary>
            Like <see cref="F:BoSSS.Solution.AdvancedSolvers.MultigridOperator.Mode.DiagBlockEquilib"/>, but only the 
            symmetric part of the diagonal block is used for equilibration; i.e. this works only for un-symmetric matrices.
            </summary>
        </member>
        <member name="F:BoSSS.Solution.AdvancedSolvers.MultigridOperator.Mode.LeftInverse_DiagBlock">
            <summary>
            multiplies from the left with the inverse of the operator matrix diagonal block.
            </summary>
        </member>
        <member name="F:BoSSS.Solution.AdvancedSolvers.MultigridOperator.Mode.IdMass_DropIndefinite">
            <summary>
            Highly experimental option, blah blah blah.
            </summary>
        </member>
        <member name="F:BoSSS.Solution.AdvancedSolvers.MultigridOperator.Mode.SymPart_DiagBlockEquilib_DropIndefinite">
            <summary>
            Highly experimental option, blah blah blah.
            </summary>
        </member>
        <member name="F:BoSSS.Solution.AdvancedSolvers.MultigridOperator.Mode.SchurComplement">
            <summary>
            Schur complement for saddle-point systems
            </summary>
        </member>
        <member name="P:BoSSS.Solution.AdvancedSolvers.MultigridOperator.Config">
            <summary>
            Multigrid Operator configuration in current level
            </summary>
        </member>
        <member name="P:BoSSS.Solution.AdvancedSolvers.MultigridOperator.Degrees">
            <summary>
            the DG degrees on this level
            </summary>
        </member>
        <member name="M:BoSSS.Solution.AdvancedSolvers.MultigridOperator.ComputeChangeOfBasis(ilPSP.LinSolvers.BlockMsrMatrix,ilPSP.LinSolvers.BlockMsrMatrix,ilPSP.LinSolvers.BlockMsrMatrix@,ilPSP.LinSolvers.BlockMsrMatrix@,ilPSP.LinSolvers.BlockMsrMatrix@,ilPSP.LinSolvers.BlockMsrMatrix@)">
            <summary>
            applies the pre-conditioning to the operator matrix
            (passed in the constructor)
            and returns the pre-conditioned matrix
            </summary>
            <param name="LeftPreCond">
            left pre-conditioning matrix
            </param>
            <param name="RightPreCond">
            right pre-conditioning matrix
            </param>
            <param name="RightPreCondInv">
            the inverse of <paramref name="RightPreCond"/> -- usually required to transform an initial guess.
            </param>
            <param name="LeftPreCondInv"></param>
            <param name="MassMatrix">
            on entry the mass matrix w.r.t. the XDG basis
            </param>
            <param name="OpMatrix">
            </param>
            <returns>
            List of indefinite row indices.
            </returns>
        </member>
        <member name="M:BoSSS.Solution.AdvancedSolvers.MultigridOperator.RankDefInvert(ilPSP.MultidimensionalArray,ilPSP.MultidimensionalArray)">
            <summary>
            Partial inversion of a matrix with zero rows and columns; not considered to be performance-critical,
            since it is only for treating pathological cases.
            </summary>
        </member>
        <member name="M:BoSSS.Solution.AdvancedSolvers.MultigridOperator.SymPart_DiagBlockEquilib_DropIndefinite(ilPSP.MultidimensionalArray,ilPSP.MultidimensionalArray,ilPSP.MultidimensionalArray,ilPSP.MultidimensionalArray,ilPSP.MultidimensionalArray)">
            <summary>
            Implementation of <see cref="F:BoSSS.Solution.AdvancedSolvers.MultigridOperator.Mode.SymPart_DiagBlockEquilib_DropIndefinite"/>
            </summary>
        </member>
        <member name="M:BoSSS.Solution.AdvancedSolvers.MultigridOperator.ModifiedInverseChol(ilPSP.MultidimensionalArray,ilPSP.MultidimensionalArray,System.Double,System.Boolean)">
            <summary>
            Modified inverse Cholesky - resp.LDL - factorization, 
            $B =  \text{mchol}^{−1}(Q)$, resp. $B = \text{mldl}^{−1}(Q)$.
            In difference to the classical inverse Cholesky/LDL, the algorithm works on
            indefinite/singular matrices Q, but may produce zero - rows in the output <paramref name="B"/>.
            </summary>
            <param name="Q">Input: some symmetric matrix $Q \in \real^{N times N}$.</param>
            <param name="B">
            Output: an upper-diagonal matrix $B \in \real^{N \times N} , so that 
            $ B^T Q B = D$.
            If $Q$ is symmetrically positive definite, $D$ is the identity matrix and $B$ is invertible.
            Otherwise, $D$ is a diagonal matrix containing
            only entries 0 and 1 in the $  \text{mchol}^{−1}$-case resp. 0, −1 and + 1 in the $  \text{mldl}^{−1}$-case.
            </param>
            <param name="threshold"></param>
            <param name="ldl">
            Switch between modified Cholesky and LDL.
            </param>
        </member>
        <member name="T:BoSSS.Solution.AdvancedSolvers.Newton">
            <summary>
            Newton solver with various Globalization (i.e. enlargement of convergence radius) options.
            </summary>
            <remarks>
            Further reading:
            - Pawlowski et. al., 2006, Globalization Techniques for Newton–Krylov Methods and Applications to the Fully Coupled Solution of the Navier–Stokes Equations, SIAM Review, Vol. 48, No. 4, pp 700-721.
            - Pawlowski et. al., 2008, Inexact Newton Dogleg Methods, SIAM Journal on Numerical Analysis, Vol. 46, No. 4, pp 2112-2132.
            - Kelley, 2003, Solving Nonlinear Equations with Newton’s Method. Fundamentals of Algorithms. Society for Industrial and Applied Mathematics, 2003. https://doi.org/10.1137/1.9780898718898.
            - Kikker, Kummer, Oberlack, 2021, A fully coupled high‐order discontinuous Galerkin solver for viscoelastic fluid flow, IJNMF, No. 6, Vol. 93, 2021, 1736--1758.
            </remarks>
        </member>
        <member name="M:BoSSS.Solution.AdvancedSolvers.Newton.#ctor(BoSSS.Solution.AdvancedSolvers.OperatorEvalOrLin,System.Collections.Generic.IEnumerable{BoSSS.Solution.AdvancedSolvers.AggregationGridBasis[]},BoSSS.Solution.AdvancedSolvers.MultigridOperator.ChangeOfBasisConfig[][])">
            <summary>
            ctor
            </summary>
        </member>
        <member name="F:BoSSS.Solution.AdvancedSolvers.Newton.MaxIter">
            <summary>
            Maximum number of Newton iterations
            </summary>
        </member>
        <member name="F:BoSSS.Solution.AdvancedSolvers.Newton.MinIter">
            <summary>
            Minimum number of Newton iterations
            </summary>
        </member>
        <member name="F:BoSSS.Solution.AdvancedSolvers.Newton.constant_newton_it">
            <summary>
            Number of iterations, where Jacobi is not updated. Also known as constant newton method. Default 1, means regular newton.
            </summary>
        </member>
        <member name="F:BoSSS.Solution.AdvancedSolvers.Newton.HomotopyStepLongFail">
            <summary>
            If, for a specific homotopy parameter value, Newton does not converges successfully,
            (within this number of iterations) a roll-back to the last solution is done and the step with is reduced
            </summary>
        </member>
        <member name="P:BoSSS.Solution.AdvancedSolvers.Newton.ConvCrit">
            <summary>
            Convergence criterion for nonlinear iteration;
            Setting it to exactly zero should enforce the nonlinear solver to iterate until no improvement on the termination criterion
            can be achieved; then, it terminates; this is described in
            Kikker, Kummer, Oberlack:
            A fully coupled high‐order discontinuous {Galerkin} solver for viscoelastic fluid flow,
            IJNMF, No. 6, Vol. 93, 2021, 1736--1758,
            section 3.3.1.
            </summary>
        </member>
        <member name="F:BoSSS.Solution.AdvancedSolvers.Newton.maxStep">
            <summary>
            Maximum number of step-length iterations
            </summary>
        </member>
        <member name="T:BoSSS.Solution.AdvancedSolvers.Newton.ApproxInvJacobianOptions">
            <summary>
            Options for (approximate) solution to the linearizes system
            </summary>
        </member>
        <member name="F:BoSSS.Solution.AdvancedSolvers.Newton.ApproxInvJacobianOptions.MatrixFreeGMRES">
            <summary>
            Using a matrix-free GMRES implementation, <see cref="T:BoSSS.Solution.AdvancedSolvers.Newton.MatrixFreeGMRES"/>
            </summary>
        </member>
        <member name="F:BoSSS.Solution.AdvancedSolvers.Newton.ApproxInvJacobianOptions.ExternalSolver">
            <summary>
            Using the solver <see cref="F:BoSSS.Solution.AdvancedSolvers.NonlinearSolver.PrecondConfig"/> for computing Newton corrections
            </summary>
        </member>
        <member name="F:BoSSS.Solution.AdvancedSolvers.Newton.ApproxJac">
            <summary>
            Options for (approximate) solution to the linearized system
            </summary>
        </member>
        <member name="T:BoSSS.Solution.AdvancedSolvers.Newton.GlobalizationOption">
            <summary>
            Options for Globalization, i.e. means to ensure convergence of Newton iterations
            when the initial guess is far away from the solution.
            </summary>
        </member>
        <member name="F:BoSSS.Solution.AdvancedSolvers.Newton.GlobalizationOption.Dogleg">
            <summary>
            Dogleg method according to
            Pawlowski et. al., 2006, Globalization Techniques for Newton–Krylov Methods and Applications to the Fully Coupled Solution of the Navier–Stokes Equations, SIAM Review, Vol. 48, No. 4, pp 700-721.
            </summary>
        </member>
        <member name="F:BoSSS.Solution.AdvancedSolvers.Newton.GlobalizationOption.LineSearch">
            <summary>
            Parabolic line search according to
            Kelley, C., Solving Nonlinear Equations with Newton’s Method. Fundamentals of Algorithms. Society for Industrial and Applied Mathematics, 2003. https://doi.org/10.1137/1.9780898718898.
            </summary>
        </member>
        <member name="F:BoSSS.Solution.AdvancedSolvers.Newton.GlobalizationOption.None">
            <summary>
            Globalization turned off
            </summary>
        </member>
        <member name="F:BoSSS.Solution.AdvancedSolvers.Newton.Globalization">
            <summary>
            Options for Globalization, i.e. means to ensure convergence of Newton iterations
            when the initial guess is far away from the solution.
            </summary>
        </member>
        <member name="P:BoSSS.Solution.AdvancedSolvers.Newton.UseHomotopy">
            <summary>
            Switch the use of the Homotopy-Path (<see cref="P:BoSSS.Foundation.ISpatialOperator.HomotopyUpdate"/>) on/off
            </summary>
        </member>
        <member name="M:BoSSS.Solution.AdvancedSolvers.Newton.SolverDriver``1(BoSSS.Foundation.CoordinateVector,``0)">
            <summary>
            Main solver routine
            </summary>
        </member>
        <member name="M:BoSSS.Solution.AdvancedSolvers.Newton.GlobalizedNewton``1(BoSSS.Foundation.CoordinateVector,``0)">
            <summary>
            Main solver routine
            </summary>
        </member>
        <member name="M:BoSSS.Solution.AdvancedSolvers.Newton.HomotopyNewton``1(BoSSS.Foundation.CoordinateVector,``0)">
            <summary>
            Main solver routine with homotopy;
            </summary>
        </member>
        <member name="M:BoSSS.Solution.AdvancedSolvers.Newton.LineSearch(BoSSS.Foundation.CoordinateVector,System.Double[],System.Double[],System.Double[],System.Double)">
            <summary>
            Newton Globalization via parabolic line search
            </summary>
            <param name="SolutionVec">
            output: updated solution in original DG coordinates
            </param>
            <param name="CurSol">
            input: current solution in the preconditioned DG coordinates
            </param>
            <param name="CurRes">
            input: residual for <paramref name="CurSol"/>
            </param>
            <param name="step">
            input: Newton step
            </param>
            <param name="HomotopyValue">
            current parameter for the homotopy curve
            </param>
            <returns>
            Updated Solution
            </returns>
        </member>
        <member name="M:BoSSS.Solution.AdvancedSolvers.Newton.ZeroGlobalization(BoSSS.Foundation.CoordinateVector,System.Double[],System.Double[],System.Double[],System.Double)">
            <summary>
            Zero Globalization
            </summary>
            <param name="SolutionVec">
            output: updated solution in original DG coordinates
            </param>
            <param name="CurSol">
            input: current solution in the preconditioned DG coordinates
            </param>
            <param name="CurRes">
            input: residual for <paramref name="CurSol"/>
            </param>
            <param name="step">
            input: Newton step
            </param>
            <param name="HomotopyValue">
            current paramter for the homotopy curve
            </param>
            <returns>
            Updated Solution
            </returns>
        </member>
        <member name="M:BoSSS.Solution.AdvancedSolvers.Newton.DogLeg(BoSSS.Foundation.CoordinateVector,System.Double[],System.Double[],System.Double[],System.Double,System.Int32,System.Double@)">
            <summary>
            Newton Globalization via Dogleg Method (a trust region approach)
            </summary>
            <param name="SolutionVec">
            output: updated solution in original DG coordinates
            </param>
            <param name="CurSol">
            input: current solution in the preconditioned DG coordinates
            </param>
            <param name="CurRes">
            input: residual for <paramref name="CurSol"/>
            </param>
            <param name="stepIN">
            input: (inexact) Newton step
            </param>
            <param name="NewtonIterCnt">
            newton iteration counter, starts at 1
            </param>
            <param name="TrustRegionDelta">
            Estimated in <paramref name="NewtonIterCnt"/>==1;
            value must be stored externally for later iterations.
            </param>
            <param name="HomotopyValue">
            <see cref="P:BoSSS.Foundation.ISpatialOperator.CurrentHomotopyValue"/>
            </param>
            <remarks>
            See:
            - Pawlowski et. al., 2006, Globalization Techniques for Newton–Krylov Methods and Applications to the Fully Coupled Solution of the Navier–Stokes Equations, SIAM Review, Vol. 48, No. 4, pp 700-721.
            - Pawlowski et. al., 2008, Inexact Newton Dogleg Methods, SIAM Journal on Numerical Analysis, Vol. 46, No. 4, pp 2112-2132.
            </remarks>
        </member>
        <member name="T:BoSSS.Solution.AdvancedSolvers.Newton.MatrixFreeGMRES">
            <summary>
            container class for all matrix-free GMRES routines
            </summary>
        </member>
        <member name="M:BoSSS.Solution.AdvancedSolvers.Newton.MatrixFreeGMRES.#ctor">
            <summary>
            ctor
            </summary>
        </member>
        <member name="F:BoSSS.Solution.AdvancedSolvers.Newton.MatrixFreeGMRES.owner">
            <summary>
            %
            </summary>
        </member>
        <member name="F:BoSSS.Solution.AdvancedSolvers.Newton.MatrixFreeGMRES.HomotopyValue">
            <summary>
            <see cref="P:BoSSS.Foundation.ISpatialOperator.CurrentHomotopyValue"/>
            </summary>
        </member>
        <member name="F:BoSSS.Solution.AdvancedSolvers.Newton.MatrixFreeGMRES.maxKrylovDim">
            <summary>
            Maximum dimension of the krylov subspace. Equals m in GMRES(m)
            </summary>
        </member>
        <member name="P:BoSSS.Solution.AdvancedSolvers.Newton.MatrixFreeGMRES.IterationsInNested">
            <summary>
            <see cref="P:BoSSS.Solution.AdvancedSolvers.ISolverSmootherTemplate.IterationsInNested"/>
            </summary>
        </member>
        <member name="P:BoSSS.Solution.AdvancedSolvers.Newton.MatrixFreeGMRES.ThisLevelIterations">
            <summary>
            <see cref="P:BoSSS.Solution.AdvancedSolvers.ISolverSmootherTemplate.ThisLevelIterations"/>
            </summary>
        </member>
        <member name="P:BoSSS.Solution.AdvancedSolvers.Newton.MatrixFreeGMRES.Converged">
            <summary>
            true if the last solver run actually worked, which is not the case very often
            </summary>
        </member>
        <member name="M:BoSSS.Solution.AdvancedSolvers.Newton.MatrixFreeGMRES.Solve(BoSSS.Foundation.CoordinateVector,System.Double[],System.Double[],System.Double[],System.Double@)">
            <summary>
            Preconditioned GMRES, using <see cref="F:BoSSS.Solution.AdvancedSolvers.NonlinearSolver.PrecondConfig"/> as a preconditioner
            </summary>
            <param name="SolutionVec">Current Point</param>
            <param name="f0">Function at current point</param>
            <param name="xinit">initial iterate</param>
            <param name="errstep">error of step</param>
            <param name="currentX"></param>
            <returns></returns>
        </member>
        <member name="M:BoSSS.Solution.AdvancedSolvers.Newton.MatrixFreeGMRES.Krylov(BoSSS.Foundation.CoordinateVector,System.Double[],System.Double[],System.Double@)">
            <summary>
            Driver routine
            </summary>
        </member>
        <member name="M:BoSSS.Solution.AdvancedSolvers.Newton.MatrixFreeGMRES.dirder(BoSSS.Foundation.CoordinateVector,System.Double[],System.Double[],System.Double[],System.Boolean)">
            <summary>
            Finite difference directional derivative Approximate f'(x) w
            C.T.Kelley, April 1, 2003
            This code comes with no guarantee or warranty of any kind.
            </summary>
            <param name="SolutionVec">Solution point</param>
            <param name="w">Direction</param>
            <param name="f0">f0, usually has been calculated earlier</param>
            <param name="linearization">True if the Operator should be linearized and evaluated afterwards</param>
            <param name="currentX">linearization point</param>
            <returns></returns>
        </member>
        <member name="M:BoSSS.Solution.AdvancedSolvers.Newton.MatrixFreeGMRES.givapp(System.Double[],System.Double[],System.Double[],System.Int32)">
            <summary>
            Apply a sequence of k Givens rotations, used within gmres codes.
            C.T.Kelley, April 1, 2003
            This code comes with no guarantee or warranty of any kind.
            </summary>
            <param name="c"></param>
            <param name="s"></param>
            <param name="vin"></param>
            <param name="k"></param>
            <returns></returns>
        </member>
        <member name="M:BoSSS.Solution.AdvancedSolvers.Newton.MatrixFreeGMRES.rotmat(System.Double@,System.Double@,System.Double,System.Double)">
            <summary>
            Compute the Givens rotation matrix parameters for a and b.
            </summary>
        </member>
        <member name="M:BoSSS.Solution.AdvancedSolvers.Newton.MatrixFreeGMRES.Init(BoSSS.Solution.AdvancedSolvers.MultigridOperator)">
            <summary>
            init
            </summary>
        </member>
        <member name="F:BoSSS.Solution.AdvancedSolvers.Newton.MatrixFreeGMRES.PrecondInstance">
            <summary>
            Instance of <see cref="F:BoSSS.Solution.AdvancedSolvers.NonlinearSolver.PrecondConfig"/>
            </summary>
        </member>
        <member name="M:BoSSS.Solution.AdvancedSolvers.Newton.MatrixFreeGMRES.Solve``2(``0,``1)">
            <summary>
            Solution routine as defined by interface
            </summary>
        </member>
        <member name="M:BoSSS.Solution.AdvancedSolvers.Newton.MatrixFreeGMRES.ResetStat">
            <summary>
            <see cref="M:BoSSS.Solution.AdvancedSolvers.ISolverSmootherTemplate.ResetStat"/>
            </summary>
        </member>
        <member name="M:BoSSS.Solution.AdvancedSolvers.Newton.parab3p(System.Double,System.Double,System.Double,System.Double,System.Double)">
             <summary>
             Apply three-point safeguarded parabolic model for a line search.
             C.T.Kelley, April 1, 2003
             This code comes with no guarantee or warranty of any kind.
             function lambdap = parab3p(lambdac, lambdam, ff0, ffc, ffm)
             input:
                    lambdac = current steplength
                    lambdam = previous steplength
                    ff0 = value of \| F(x_c) \|^2
                    ffc = value of \| F(x_c + \lambdac d) \|^2
                    ffm = value of \| F(x_c + \lambdam d) \|^2
            
             output:
             lambdap = new value of lambda given parabolic model
            
             internal parameters:
             sigma0 = .1, sigma1 = .5, safeguarding bounds for the linesearch
             </summary>
             <param name="lambdac"></param>
             <param name="lambdam"></param>
             <param name="ff0"></param>
             <param name="ffc"></param>
             <param name="ffm"></param>
             <returns></returns>
        </member>
        <member name="T:BoSSS.Solution.AdvancedSolvers.OperatorEvalOrLin">
            <summary>
            Evaluation or linearization/matrix assembly of the operator;
            this delegate is, so-to-say, the connection between the used <see cref="T:BoSSS.Foundation.ISpatialOperator"/> and its evaluation/linearization,
            which can be used to build a <see cref="T:BoSSS.Solution.AdvancedSolvers.MultigridOperator"/>
            </summary>
            <param name="Matrix"></param>
            <param name="Affine"></param>
            <param name="Linearization">
            - false: operator evaluation
            - true: linearization
            </param>
            <param name="MassMatrix"></param>
            <param name="CurrentState">
            Current state of the solution
            </param>
            <param name="OberFrickelHack">
            the original operator that somehow produced the matrix; yes, this API is convoluted piece-of-shit
            </param>
            <remarks>
            As a recipe, this function does:
            1. compute linearization/evaluation at the current state , i.e. 
            1.1 in the case of `Linearization == true`,
                compute the operator matrix (<see cref="P:BoSSS.Foundation.ISpatialOperator.LinearizationHint"/>, <see cref="M:BoSSS.Foundation.ISpatialOperator.GetMatrixBuilder(BoSSS.Foundation.UnsetteledCoordinateMapping,System.Collections.Generic.IList{BoSSS.Foundation.DGField},BoSSS.Foundation.UnsetteledCoordinateMapping)"/>, <see cref="M:BoSSS.Foundation.ISpatialOperator.GetJacobiOperator(System.Int32)"/>, <see cref="M:BoSSS.Foundation.ISpatialOperator.GetFDJacobianBuilder(System.Collections.Generic.IList{BoSSS.Foundation.DGField},System.Collections.Generic.IList{BoSSS.Foundation.DGField},BoSSS.Foundation.UnsetteledCoordinateMapping)"/>)
            1.2 in the case of `Linearization == false`,
                evaluate the operator (<see cref="M:BoSSS.Foundation.ISpatialOperator.GetEvaluatorEx(System.Collections.Generic.IList{BoSSS.Foundation.DGField},System.Collections.Generic.IList{BoSSS.Foundation.DGField},BoSSS.Foundation.UnsetteledCoordinateMapping)"/>)
            2. add timestepping terms (<see cref="P:BoSSS.Foundation.ISpatialOperator.TemporalOperator"/>), also depending on the actual timestepping scheme (e.g. BDF or Runge-Kutta)
            3. Compute the mass matrix
            4. perform the agglomeration (<see cref="M:BoSSS.Foundation.XDG.LevelSetTracker.GetAgglomerator(BoSSS.Foundation.XDG.SpeciesId[],System.Int32,System.Double,System.Boolean,System.Boolean,System.Boolean,System.Double[],System.Double)"/>
            </remarks>
        </member>
        <member name="T:BoSSS.Solution.AdvancedSolvers.NonlinearSolver">
            <summary>
            base-class for non-linear solvers
            </summary>
        </member>
        <member name="M:BoSSS.Solution.AdvancedSolvers.NonlinearSolver.#ctor(BoSSS.Solution.AdvancedSolvers.OperatorEvalOrLin,System.Collections.Generic.IEnumerable{BoSSS.Solution.AdvancedSolvers.AggregationGridBasis[]},BoSSS.Solution.AdvancedSolvers.MultigridOperator.ChangeOfBasisConfig[][])">
            <summary>
            ctor
            </summary>
        </member>
        <member name="F:BoSSS.Solution.AdvancedSolvers.NonlinearSolver.m_AssembleMatrix">
            <summary>
            Evaluation and linearization of PDE to solve
            </summary>
        </member>
        <member name="P:BoSSS.Solution.AdvancedSolvers.NonlinearSolver.AbstractOperator">
            <summary>
            spatial operator provided by <see cref="F:BoSSS.Solution.AdvancedSolvers.NonlinearSolver.m_AssembleMatrix"/>;
            </summary>
        </member>
        <member name="F:BoSSS.Solution.AdvancedSolvers.NonlinearSolver.m_AggBasisSeq">
            <summary>
            Multigrid basis
            - 1st index: Multigrid level
            - 2nd index: variable index
            </summary>
        </member>
        <member name="F:BoSSS.Solution.AdvancedSolvers.NonlinearSolver.m_MultigridOperatorConfig">
            <summary>
            required for construction of <see cref="F:BoSSS.Solution.AdvancedSolvers.NonlinearSolver.CurrentLin"/>
            </summary>
        </member>
        <member name="E:BoSSS.Solution.AdvancedSolvers.NonlinearSolver.IterationCallback">
            <summary>
            Called at every iteration; the arguments are 
             - iteration index 
             - current solution 
             - current residual 
             - current multigrid operator
            </summary>
        </member>
        <member name="M:BoSSS.Solution.AdvancedSolvers.NonlinearSolver.OnIterationCallback(System.Int32,System.Double[],System.Double[],BoSSS.Solution.AdvancedSolvers.MultigridOperator)">
            <summary>
            Triggers <see cref="E:BoSSS.Solution.AdvancedSolvers.NonlinearSolver.IterationCallback"/>.
            </summary>
        </member>
        <member name="M:BoSSS.Solution.AdvancedSolvers.NonlinearSolver.Init``1(BoSSS.Foundation.CoordinateVector,``0,System.Double[]@,System.Double[]@)">
            <summary>
            Helper routine for the initial phase of <see cref="M:BoSSS.Solution.AdvancedSolvers.NonlinearSolver.SolverDriver``1(BoSSS.Foundation.CoordinateVector,``0)"/>
            </summary>
            <param name="X">initial guess</param>
            <param name="RHS"></param>
            <param name="Sol1">
            The initial solution, transformed to the aggregation multigrid basis, see <see cref="F:BoSSS.Solution.AdvancedSolvers.NonlinearSolver.m_AggBasisSeq"/>.
            </param>
            <param name="Res1">
            The residual of the initial solution
            </param>
        </member>
        <member name="M:BoSSS.Solution.AdvancedSolvers.NonlinearSolver.SolverDriver``1(BoSSS.Foundation.CoordinateVector,``0)">
            <summary>
            Template for implementation of the solver routine.
            </summary>
            <typeparam name="S"></typeparam>
            <param name="X">
            On entry, an initial guess to the linear system.
            On exit, hopefully the solution to the nonlinear system.
            </param>
            <param name="RHS">
            If not equal null, must be passed to <see cref="F:BoSSS.Solution.AdvancedSolvers.NonlinearSolver.RHSRaw"/>.
            </param>
            <returns>
            - true: solver algorithm successfully converged
            - false: something went wrong
            </returns>
        </member>
        <member name="P:BoSSS.Solution.AdvancedSolvers.NonlinearSolver.NoOfNonlinearIter">
            <summary>
            Number of nonlinear iterations in last call to <see cref="M:BoSSS.Solution.AdvancedSolvers.NonlinearSolver.SolverDriver``1(BoSSS.Foundation.CoordinateVector,``0)"/>
            </summary>
        </member>
        <member name="F:BoSSS.Solution.AdvancedSolvers.NonlinearSolver.PrecondConfig">
            <summary>
            Preconditioner/solver configuration for the linearized problem
            </summary>
        </member>
        <member name="F:BoSSS.Solution.AdvancedSolvers.NonlinearSolver.CurrentLin">
            <summary>
            Current linearization of the nonlinear operator: the linearized
            system is given as 
            <see cref="F:BoSSS.Solution.AdvancedSolvers.NonlinearSolver.CurrentLin"/>*X = <see cref="F:BoSSS.Solution.AdvancedSolvers.NonlinearSolver.LinearizationRHS"/>.
            </summary>
        </member>
        <member name="P:BoSSS.Solution.AdvancedSolvers.NonlinearSolver.EssentialDOFs">
            <summary>
            number of DOFs in linearization of last iteration
            </summary>
        </member>
        <member name="F:BoSSS.Solution.AdvancedSolvers.NonlinearSolver.RHSRaw">
            <summary>
            Optional RHS to the nonlinear system, 
            </summary>
        </member>
        <member name="F:BoSSS.Solution.AdvancedSolvers.NonlinearSolver.LinearizationRHS">
            <summary>
            Current affine part of the nonlinear operator.
            </summary>
        </member>
        <member name="M:BoSSS.Solution.AdvancedSolvers.NonlinearSolver.EvaluateOperator(System.Double,System.Collections.Generic.IEnumerable{BoSSS.Foundation.DGField},System.Double[],System.Double,System.Boolean)">
            <summary>
            Evaluation of the nonlinear operator.
            </summary>
            <param name="alpha"></param>
            <param name="CurrentState">
            Current state of DG fields
            </param>
            <param name="Output"></param>
            <param name="HomotopyValue">
            <see cref="P:BoSSS.Foundation.ISpatialOperator.CurrentHomotopyValue"/>
            </param>
            <param name="ApplyRef">
            apply additional modification due to free-mean-value fixing (aka. pressure reference point), <see cref="P:BoSSS.Solution.AdvancedSolvers.MultigridOperator.FreeMeanValue"/>
            </param>        
        </member>
        <member name="M:BoSSS.Solution.AdvancedSolvers.NonlinearSolver.Update(System.Collections.Generic.IEnumerable{BoSSS.Foundation.DGField},System.Double[],System.Double)">
            <summary>
            Updating the <see cref="F:BoSSS.Solution.AdvancedSolvers.NonlinearSolver.CurrentLin"/> -- operator;
            </summary>
            <param name="CurrentState">input, linearization point</param>
            <param name="U0">output, linearization point, after external update, transformed back</param>
            <param name="HomotopyValue">
            <see cref="P:BoSSS.Foundation.ISpatialOperator.CurrentHomotopyValue"/>
            </param>
        </member>
        <member name="M:BoSSS.Solution.AdvancedSolvers.NonlinearSolver.UpdateLinearization(System.Collections.Generic.IEnumerable{BoSSS.Foundation.DGField},System.Double)">
            <summary>
            Updating the <see cref="F:BoSSS.Solution.AdvancedSolvers.NonlinearSolver.CurrentLin"/> -- operator;
            </summary>
            <param name="CurrentState">linearization point</param>
            <param name="HomotopyValue">
            <see cref="P:BoSSS.Foundation.ISpatialOperator.CurrentHomotopyValue"/>
            </param>
        </member>
        <member name="M:BoSSS.Solution.AdvancedSolvers.NonlinearSolver.TestFreeMeanValue(BoSSS.Foundation.CoordinateVector,System.Double)">
            <summary>
            This method tests that, 
            if any entry in <see cref="P:BoSSS.Foundation.ISpatialOperator.FreeMeanValue"/> is true, 
            a change in the mean/average value of the respective variable must **not** have any effect on the residual.
            </summary>
        </member>
        <member name="P:BoSSS.Solution.AdvancedSolvers.NonlinearSolver.ProblemMapping">
            <summary>
            DG Coordinate mapping for the base DG/XDG space, without any multigrid fuzz
            </summary>
        </member>
        <member name="M:BoSSS.Solution.AdvancedSolvers.NonlinearSolver.EvalLinearizedResidual(System.Double[],System.Double[]@)">
            <summary>
            Residual of linearized system, i.e.
            <paramref name="out_Resi"/> := RHS - M*<paramref name="in_U"/>
            </summary>
        </member>
        <member name="M:BoSSS.Solution.AdvancedSolvers.NonlinearSolver.InnerProduct``2(``0,``0)">
            <summary>
            Inner product with respect to the current mass matrix.
            
            Note: this is the canonical inner product of the underlying DG-space, since 
            for a DG/XDG field represented in an arbitrary basis $` \phi_{j} $` one verifies that
            ```math
                    (u, v) = 
                \int_\Omega 
                    \left( \sum_{j} \phi_{j} \tilde{u}_{j} \right) 
                    \left( \sum_{l} \phi_{l} \tilde{v}_{l} \right) 
                dV = 
                \sum_{j l} \tilde{u}_{j} \tilde{v}_{l} ( \phi_{j}, \phi_{l} )
                =
                  \tilde{u}^T M \tilde{v},
            ```
            where $`M `$ denotes the mass matrix ($` M_{j l} = ( \phi_ { j}, \phi_ { l} )  `$).
            </summary>
        </member>
        <member name="M:BoSSS.Solution.AdvancedSolvers.NonlinearSolver.Norm``1(``0)">
            <summary>
            Norm induced by <see cref="M:BoSSS.Solution.AdvancedSolvers.NonlinearSolver.InnerProduct``2(``0,``0)"/>
            </summary>
        </member>
        <member name="T:BoSSS.Solution.AdvancedSolvers.OrthoMGILUconfig">
            <summary>
            Dynamic configuration for the orthonormalization multigrid.
            As smoothers, <see cref="T:BoSSS.Solution.AdvancedSolvers.CellILU"/> is used on all mesh levels, except the coarsest one.
            There, a direct solver is used.
            The coarsest level is determined dynamically, depending on the problem and the mesh size using <see cref="F:BoSSS.Solution.AdvancedSolvers.OrthoMGILUconfig.TargetBlockSize"/>.
            </summary>
        </member>
        <member name="P:BoSSS.Solution.AdvancedSolvers.OrthoMGILUconfig.Name">
            <summary>
            
            </summary>
        </member>
        <member name="P:BoSSS.Solution.AdvancedSolvers.OrthoMGILUconfig.Shortname">
            <summary>
            
            </summary>
        </member>
        <member name="F:BoSSS.Solution.AdvancedSolvers.OrthoMGILUconfig.TargetBlockSize">
            <summary>
            If any blocking is used (Schwarz, block Jacobi), a target for the block size.
            Tests show that the ideal block size may be around 10000, but this may depend on computer, DG polynomial order, etc.
            
            This also determines the actual number of multigrid levels used in dependence of the problem size;
            As soon as the number of DOF's on a certain multigrid level fall below this threshold, a direct 
            solver is used and no further multigrid levels are allocated.
            </summary>
        </member>
        <member name="T:BoSSS.Solution.AdvancedSolvers.OrthoMGSchwarzConfig">
            <summary>
            Dynamic configuration for the orthonormalization multigrid.
            As smoothers, additive Schwarz (<see cref="T:BoSSS.Solution.AdvancedSolvers.Schwarz"/>) is used on all mesh levels, except the coarsest one.
            There, a direct solver is used.
            The coarsest level is determined dynamically, depending on the problem and the mesh size using <see cref="F:BoSSS.Solution.AdvancedSolvers.OrthoMGSchwarzConfig.TargetBlockSize"/>.
            </summary>
        </member>
        <member name="F:BoSSS.Solution.AdvancedSolvers.OrthoMGSchwarzConfig.TargetBlockSize">
            <summary>
            If any blocking is used (Schwarz, block Jacobi), a target for the block size.
            Tests show that the ideal block size may be around 10000, but this may depend on computer, DG polynomial order, etc.
            
            This also determines the actual number of multigrid levels used in dependence of the problem size;
            As soon as the number of DOF's on a certain multigrid level fall below this threshold, a direct 
            solver is used and no further multigrid levels are allocated.
            </summary>
        </member>
        <member name="F:BoSSS.Solution.AdvancedSolvers.OrthoMGSchwarzConfig.pMaxOfCoarseSolver">
            <summary>
            Determines maximal DG order within coarse system of a p-Multigrid. 
            </summary>
        </member>
        <member name="F:BoSSS.Solution.AdvancedSolvers.OrthoMGSchwarzConfig.NoOfMultigridLevels">
            <summary>
            Sets the **maximum** number of Multigrid levels to be used.
            The numbers of levels which are actually used is probably much less, and determined via <see cref="F:BoSSS.Solution.AdvancedSolvers.OrthoMGSchwarzConfig.TargetBlockSize"/>.
            Multigrid approach is used to get a preconditioner for Krylov solvers, e.g. GMRES.
            </summary>
        </member>
        <member name="F:BoSSS.Solution.AdvancedSolvers.OrthoMGSchwarzConfig.UsepTG">
            <summary>
            Use a p-two-grid approach in Additive Schwarz (<see cref="F:BoSSS.Solution.AdvancedSolvers.Schwarz.Config.UsePMGinBlocks"/>).
            
            This results in a lesser number of Schwarz blocks and more computational cells per Schwarz block.
            It seems to accelerate convergence for certain problems (mostly single-phase).
            The order of the low-order system can be adjusted using <see cref="F:BoSSS.Solution.AdvancedSolvers.OrthoMGSchwarzConfig.pMaxOfCoarseSolver"/>.
            </summary>
        </member>
        <member name="P:BoSSS.Solution.AdvancedSolvers.OrthoMGSchwarzConfig.Name">
            <summary>
            
            </summary>
        </member>
        <member name="P:BoSSS.Solution.AdvancedSolvers.OrthoMGSchwarzConfig.Shortname">
            <summary>
            
            </summary>
        </member>
        <member name="M:BoSSS.Solution.AdvancedSolvers.OrthoMGSchwarzConfig.CreateInstance(BoSSS.Solution.AdvancedSolvers.MultigridOperator)">
            <summary>
            
            </summary>
        </member>
        <member name="M:BoSSS.Solution.AdvancedSolvers.OrthoMGSchwarzConfig.NoOfBlocksAtLevel(BoSSS.Solution.AdvancedSolvers.MultigridOperator,System.Int32,System.Int32,System.Func{System.Int32,System.Int32})">
            <summary>
            Number of Blocks at this level. Minimum 1 per core
            </summary>
        </member>
        <member name="M:BoSSS.Solution.AdvancedSolvers.OrthoMGSchwarzConfig.NoOfSchwarzBlocks(BoSSS.Solution.AdvancedSolvers.MultigridOperator,System.Int32,System.Func{System.Int32,System.Int32})">
            <summary>
            No Of Local Schwarz Blocks (process local) for all MG levels
            </summary>
        </member>
        <member name="T:BoSSS.Solution.AdvancedSolvers.CoreOrthonormalizationProcedure">
            <summary>
            
            </summary>
            <remarks>
            First described in: 
             Vinsome, P.K.W.: 
             Orthomin, an Iterative Method for Solving Sparse Sets of Simultaneous Linear Equations,
             SPE Symposium on Numerical Simulation of Reservoir Performance, 
             doi: 10.2118/5729-MS, Los Angeles, California, 1976
            </remarks>
        </member>
        <member name="P:BoSSS.Solution.AdvancedSolvers.CoreOrthonormalizationProcedure.OpMatrix">
            <summary>
            
            </summary>
        </member>
        <member name="F:BoSSS.Solution.AdvancedSolvers.CoreOrthonormalizationProcedure.SolHistory">
            <summary>
            solution guesses from smoothers
            </summary>
        </member>
        <member name="F:BoSSS.Solution.AdvancedSolvers.CoreOrthonormalizationProcedure.MxxHistory">
            <summary>
            - orthonormal system of matrix-vector products;
            - the i-th entry is equal to  <see cref="P:BoSSS.Solution.AdvancedSolvers.CoreOrthonormalizationProcedure.OpMatrix"/>*<see cref="F:BoSSS.Solution.AdvancedSolvers.CoreOrthonormalizationProcedure.SolHistory"/>[i]
            </summary>
        </member>
        <member name="F:BoSSS.Solution.AdvancedSolvers.CoreOrthonormalizationProcedure.Alphas">
            <summary>
            scaling factors which were applied to <see cref="F:BoSSS.Solution.AdvancedSolvers.CoreOrthonormalizationProcedure.SolHistory"/> to approximate the solution
            - 1st item: the scaling applied to the respective solutions provided through <see cref="M:BoSSS.Solution.AdvancedSolvers.CoreOrthonormalizationProcedure.AddSol(System.Double[]@,System.String)"/>
            - 2nd: relative residual reduction (typically greater or equal to 1)
            - 3rd: user id data
            </summary>
        </member>
        <member name="M:BoSSS.Solution.AdvancedSolvers.CoreOrthonormalizationProcedure.FullMinimization(System.Double[],System.Double[],System.Double[],System.Double[])">
            <summary>
            
            </summary>
        </member>
        <member name="M:BoSSS.Solution.AdvancedSolvers.CoreOrthonormalizationProcedure.MinimizeResidual(System.Double[],System.Double[],System.Double[],System.Double[],System.String)">
            <summary>
            Residual minimization in the space spanned by <see cref="F:BoSSS.Solution.AdvancedSolvers.CoreOrthonormalizationProcedure.SolHistory"/>/<see cref="F:BoSSS.Solution.AdvancedSolvers.CoreOrthonormalizationProcedure.MxxHistory"/>
            </summary>
            <param name="outX">
            - input: the solution build upon all vectors in the Krylov space **except the last one**
            - output: on exit, updated by the contribution from the most recent Krylov basis
            </param>
            <param name="Res0">
            residual with respect to the initial guess
            </param>
            <param name="Sol0">
            initial guess; required for checking <paramref name="outRes"/>,
            resp. for re-computing <paramref name="outRes"/> in the case of severe round-of errors.
            </param>
            <param name="outRes">
            - input: the residual with respect to the input value of <paramref name="outX"/>
            - output: on exit, the residual with respect to the output value of <paramref name="outX"/>
            </param>
            <param name="id">
            name/information for debugging and analysis
            </param>
        </member>
        <member name="M:BoSSS.Solution.AdvancedSolvers.CoreOrthonormalizationProcedure.AddSol(System.Double[]@,System.String)">
            <summary>
            
            </summary>
            <param name="X"></param>
            <param name="name"></param>
        </member>
        <member name="M:BoSSS.Solution.AdvancedSolvers.CoreOrthonormalizationProcedure.InnerProduct(System.Double[],System.Double[])">
            <summary>
            Inner Product use for orthonormalization (not necessarily the standard l2-product)
            </summary>
        </member>
        <member name="M:BoSSS.Solution.AdvancedSolvers.CoreOrthonormalizationProcedure.Norm(System.Double[])">
            <summary>
            norm induced by <see cref="M:BoSSS.Solution.AdvancedSolvers.CoreOrthonormalizationProcedure.InnerProduct(System.Double[],System.Double[])"/>
            </summary>
        </member>
        <member name="M:BoSSS.Solution.AdvancedSolvers.CoreOrthonormalizationProcedure.AddSolAndMinimizeResidual(System.Double[]@,System.Double[],System.Double[],System.Double[],System.Double[],System.String)">
            <summary>
            Residual minimization in the space spanned by <see cref="F:BoSSS.Solution.AdvancedSolvers.CoreOrthonormalizationProcedure.SolHistory"/>/<see cref="F:BoSSS.Solution.AdvancedSolvers.CoreOrthonormalizationProcedure.MxxHistory"/>
            </summary>
            <param name="outX">
            - input: the solution build upon all vectors in the Krylov space **except the last one**
            - output: on exit, updated by the contribution from the most recent Krylov basis
            </param>
            <param name="Res0">
            residual with respect to the initial guess
            </param>
            <param name="Sol0">
            initial guess; required for checking <paramref name="outRes"/>,
            resp. for re-computing <paramref name="outRes"/> in the case of severe round-of errors.
            </param>
            <param name="outRes">
            - input: the residual with respect to the input value of <paramref name="outX"/>
            - output: on exit, the residual with respect to the output value of <paramref name="outX"/>
            </param>
            <param name="name">
            identifier 
            </param>
            <param name="xGuess">
            guess for the solution (typically, preconditioner output); will be modified during the orthonormalization
            </param>
        </member>
        <member name="T:BoSSS.Solution.AdvancedSolvers.OrthonormalizationMultigrid">
            <summary>
            A recursive multigrid method, where the convergence (i.e. non-divergence) of each mesh level is guaranteed by an
            orthonormalization approach, similar to flexible GMRES, 
            as described in:
              BoSSS: A package for multigrid extended discontinuous Galerkin methods; Kummer, Florian; Weber, Jens; Smuda, Martin; Computers &amp; Mathematics with Applications 81
              see https://www.sciencedirect.com/science/article/abs/pii/S0898122120301917?via%3Dihub
              see also https://tubiblio.ulb.tu-darmstadt.de/121465/
              
            One instance of this class represents only one level of the multigrid method; coarser 
            levels must be added by configuring the <see cref="F:BoSSS.Solution.AdvancedSolvers.OrthonormalizationMultigrid.CoarserLevelSolver"/> member.
            </summary>
            <remarks>
            Residual minimization through orthonormalization (ORTHOMIN) is first described in:
             Vinsome, P.K.W.: 
             Orthomin, an Iterative Method for Solving Sparse Sets of Simultaneous Linear Equations,
             SPE Symposium on Numerical Simulation of Reservoir Performance, 
             doi: 10.2118/5729-MS, Los Angeles, California, 1976
            </remarks>    
        </member>
        <member name="T:BoSSS.Solution.AdvancedSolvers.OrthonormalizationMultigrid.Config">
            <summary>
            Individual configuration of <see cref="T:BoSSS.Solution.AdvancedSolvers.OrthonormalizationMultigrid"/>
            </summary>
        </member>
        <member name="M:BoSSS.Solution.AdvancedSolvers.OrthonormalizationMultigrid.Config.#ctor">
            <summary>
            Ctor
            </summary>
        </member>
        <member name="F:BoSSS.Solution.AdvancedSolvers.OrthonormalizationMultigrid.Config.MaxKrylovDim">
            <summary>
            config cctor of <see cref="T:BoSSS.Solution.AdvancedSolvers.OrthonormalizationMultigrid"/>
            </summary>
        </member>
        <member name="F:BoSSS.Solution.AdvancedSolvers.OrthonormalizationMultigrid.Config.CoarseOnLovwerLevel">
            <summary>
            - True: the default value: <see cref="F:BoSSS.Solution.AdvancedSolvers.OrthonormalizationMultigrid.CoarserLevelSolver"/> is initialized and solved on coarser level
            - false: <see cref="F:BoSSS.Solution.AdvancedSolvers.OrthonormalizationMultigrid.CoarserLevelSolver"/> is initialized on the same level, but it may perform tis own restriction
            </summary>
        </member>
        <member name="F:BoSSS.Solution.AdvancedSolvers.OrthonormalizationMultigrid.Config.m_omega">
            <summary>
            - if set to 1, a this performs a V-cycle
            - if set to 2 or higher, a W-cycle, resp. WW-cycle, WWW-cycle, etc.
            </summary>
        </member>
        <member name="P:BoSSS.Solution.AdvancedSolvers.OrthonormalizationMultigrid.Config.Name">
            <summary>
            
            </summary>
        </member>
        <member name="P:BoSSS.Solution.AdvancedSolvers.OrthonormalizationMultigrid.Config.Shortname">
            <summary>
            
            </summary>
        </member>
        <member name="M:BoSSS.Solution.AdvancedSolvers.OrthonormalizationMultigrid.Config.CreateInstance(BoSSS.Solution.AdvancedSolvers.MultigridOperator)">
            <summary>
            factory
            </summary>
        </member>
        <member name="F:BoSSS.Solution.AdvancedSolvers.OrthonormalizationMultigrid.Config.NoOfPostSmootherSweeps">
            <summary>
            
            </summary>
        </member>
        <member name="P:BoSSS.Solution.AdvancedSolvers.OrthonormalizationMultigrid.config">
            <summary>
            Solver configuration
            </summary>
        </member>
        <member name="M:BoSSS.Solution.AdvancedSolvers.OrthonormalizationMultigrid.#ctor">
            <summary>
            ctor
            </summary>
        </member>
        <member name="P:BoSSS.Solution.AdvancedSolvers.OrthonormalizationMultigrid.TerminationCriterion">
            <summary>
            ~
            </summary>
        </member>
        <member name="P:BoSSS.Solution.AdvancedSolvers.OrthonormalizationMultigrid.OpMatrix">
            <summary>
            The matrix at this level.
            </summary>
        </member>
        <member name="F:BoSSS.Solution.AdvancedSolvers.OrthonormalizationMultigrid.m_MgOperator">
            <summary>
            passed in <see cref="M:BoSSS.Solution.AdvancedSolvers.OrthonormalizationMultigrid.InitImpl(BoSSS.Solution.AdvancedSolvers.IOperatorMappingPair)"/>
            </summary>
        </member>
        <member name="M:BoSSS.Solution.AdvancedSolvers.OrthonormalizationMultigrid.Init(BoSSS.Solution.AdvancedSolvers.IOperatorMappingPair)">
            <summary>
            defines the problem matrix
            </summary>
        </member>
        <member name="M:BoSSS.Solution.AdvancedSolvers.OrthonormalizationMultigrid.Init(BoSSS.Solution.AdvancedSolvers.MultigridOperator)">
            <summary>
            defines the problem matrix
            </summary>
        </member>
        <member name="F:BoSSS.Solution.AdvancedSolvers.OrthonormalizationMultigrid.CoarserLevelSolver">
            <summary>
            coarse-level correction; can be defined either
            - on this level (then the coarse solver may perform its of prolongation/restriction), or
            - on coarser level, then prolongation/restriction is handled by this solver.
            </summary>
        </member>
        <member name="F:BoSSS.Solution.AdvancedSolvers.OrthonormalizationMultigrid.PreSmoother">
            <summary>
            high frequency solver before coarse grid correction
            </summary>
        </member>
        <member name="F:BoSSS.Solution.AdvancedSolvers.OrthonormalizationMultigrid.PostSmoother">
            <summary>
            high frequency solver after coarse grid correction
            </summary>
        </member>
        <member name="F:BoSSS.Solution.AdvancedSolvers.OrthonormalizationMultigrid.AdditionalPostSmoothers">
            <summary>
            high frequency solver after coarse grid correction
            </summary>
        </member>
        <member name="P:BoSSS.Solution.AdvancedSolvers.OrthonormalizationMultigrid.IterationCallback">
            <summary>
            
            </summary>
        </member>
        <member name="M:BoSSS.Solution.AdvancedSolvers.OrthonormalizationMultigrid.Residual(System.Double[],System.Double[],System.Double[])">
            <summary>
            computes the residual on this level.
            </summary>
            <param name="B">input: RHS of the system</param>
            <param name="X">input: solution approximation</param>
            <param name="Res">output: on exit <paramref name="B"/> - <see cref="P:BoSSS.Solution.AdvancedSolvers.OrthonormalizationMultigrid.OpMatrix"/>*<paramref name="X"/></param>
        </member>
        <member name="M:BoSSS.Solution.AdvancedSolvers.OrthonormalizationMultigrid.Solve``2(``0,``1)">
            <summary>
            the multigrid iterations for a linear problem
            </summary>
            <param name="_xl">on input, the initial guess; on exit, the result of the multigrid iteration</param>
            <param name="_B">the right-hand-side of the problem</param>
        </member>
        <member name="M:BoSSS.Solution.AdvancedSolvers.OrthonormalizationMultigrid.VerivyCurrentResidual(System.Double[],System.Double[],System.Double[],System.Int32)">
            <summary>
            For performance optimization, the <see cref="T:BoSSS.Solution.AdvancedSolvers.OrthonormalizationMultigrid"/>
            assumes that <see cref="F:BoSSS.Solution.AdvancedSolvers.OrthonormalizationMultigrid.PreSmoother"/> and <see cref="F:BoSSS.Solution.AdvancedSolvers.OrthonormalizationMultigrid.PostSmoother"/>
            update the residual on exit.
            </summary>
            <param name="X"></param>
            <param name="B"></param>
            <param name="Res"></param>
            <param name="iter"></param>
        </member>
        <member name="P:BoSSS.Solution.AdvancedSolvers.OrthonormalizationMultigrid.IterationsInNested">
            <summary>
            ~
            </summary>
        </member>
        <member name="P:BoSSS.Solution.AdvancedSolvers.OrthonormalizationMultigrid.ThisLevelIterations">
            <summary>
            %
            </summary>
        </member>
        <member name="P:BoSSS.Solution.AdvancedSolvers.OrthonormalizationMultigrid.Converged">
            <summary>
            %
            </summary>
        </member>
        <member name="M:BoSSS.Solution.AdvancedSolvers.OrthonormalizationMultigrid.ResetStat">
            <summary>
            %
            </summary>
        </member>
        <member name="M:BoSSS.Solution.AdvancedSolvers.OrthonormalizationMultigrid.Clone">
            <summary>
            %
            </summary>
        </member>
        <member name="T:BoSSS.Solution.AdvancedSolvers.PmgConfig">
            <summary>
            Orthonormalization (<see cref="T:BoSSS.Solution.AdvancedSolvers.OrthonormalizationMultigrid"/>) scheme with full p-multigrid (i.e. multigrid over DG polynomial degree) preconditioning.
            In comparison to <see cref="T:BoSSS.Solution.AdvancedSolvers.PTGconfig"/>, where only two p-levels are used, this uses all available p-levels.
            </summary>
        </member>
        <member name="P:BoSSS.Solution.AdvancedSolvers.PmgConfig.Name">
            <summary>
            
            </summary>
        </member>
        <member name="P:BoSSS.Solution.AdvancedSolvers.PmgConfig.Shortname">
            <summary>
            
            </summary>
        </member>
        <member name="F:BoSSS.Solution.AdvancedSolvers.PmgConfig.UseILU">
            <summary>
            - true: <see cref="T:BoSSS.Solution.AdvancedSolvers.CellILU"/> is used as smoother on finest p-level
            - false: <see cref="T:BoSSS.Solution.AdvancedSolvers.BlockJacobi"/> is used as smoother on finest p-level
            </summary>
        </member>
        <member name="M:BoSSS.Solution.AdvancedSolvers.PmgConfig.CreateInstanceImpl__Kummer(BoSSS.Solution.AdvancedSolvers.IOperatorMappingPair,System.Int32[][])">
            <summary>
            Our own approach (see also <see cref="M:BoSSS.Solution.AdvancedSolvers.PmgConfig.CreateInstanceImpl__BottiDiPietro(BoSSS.Solution.AdvancedSolvers.IOperatorMappingPair,System.Int32[][])"/>):
            p-Multigrid using <see cref="T:BoSSS.Solution.AdvancedSolvers.OrthonormalizationMultigrid"/> as a multigrid and <see cref="T:BoSSS.Solution.AdvancedSolvers.CellILU"/> or <see cref="T:BoSSS.Solution.AdvancedSolvers.BlockJacobi"/> as smoother
            </summary>
        </member>
        <member name="M:BoSSS.Solution.AdvancedSolvers.PmgConfig.CreateInstanceImpl__BottiDiPietro(BoSSS.Solution.AdvancedSolvers.IOperatorMappingPair,System.Int32[][])">
            <summary>
            Approach according to (Botti, Di Pietro, 2021: p‑Multilevel Preconditioners for HHO Discretizations of the Stokes Equations with Static Condensation):
            p-Multigrid using <see cref="T:BoSSS.Solution.AdvancedSolvers.ClassicMultigrid"/> and <see cref="T:BoSSS.Solution.AdvancedSolvers.SoftGMRES"/> with <see cref="T:BoSSS.Solution.AdvancedSolvers.CellILU"/> or <see cref="T:BoSSS.Solution.AdvancedSolvers.BlockJacobi"/> as smoother.
            </summary>
            <returns></returns>
            <remarks>
            - the Botti and DiPietro approach uses only ILU, so <see cref="F:BoSSS.Solution.AdvancedSolvers.PmgConfig.UseILU"/> must be set to true to comply with their findings;
            - or own approach (<see cref="M:BoSSS.Solution.AdvancedSolvers.PmgConfig.CreateInstanceImpl__Kummer(BoSSS.Solution.AdvancedSolvers.IOperatorMappingPair,System.Int32[][])"/>) out-performs this configuration;
              E.g. in their 2D test-case, polynomial order 5, 576 cells on one processor:
              - Botti and Di Pietro: 32 iter, 24 sec
              - Kummer: 7 iter, 3.3 sec
            </remarks>
        </member>
        <member name="T:BoSSS.Solution.AdvancedSolvers.PTGconfig">
            <summary>
            GMRES with p-two-grid preconditioner (<see cref="T:BoSSS.Solution.AdvancedSolvers.LevelPmg"/>).
            
            Should work well for intermediate-size-systems, where the embedded low-order system on the finest mesh is sufficiently small for the 
            direct solver.
            </summary>
        </member>
        <member name="F:BoSSS.Solution.AdvancedSolvers.PTGconfig.pMaxOfCoarseSolver">
            <summary>
            Determines maximal DG order within coarse system of the p-Multigrid. 
            </summary>
        </member>
        <member name="F:BoSSS.Solution.AdvancedSolvers.PTGconfig.UseDiagonalPmg">
            <summary>
            If true, the high order system is solved cell-by-cell (i.e. a Block-Jacobi)
            </summary>
        </member>
        <member name="F:BoSSS.Solution.AdvancedSolvers.PTGconfig.UseHiOrderSmoothing">
            <summary>
            If true, cell-local solvers will be used to approximate a solution to high-order modes
            (this is equivalent to a Block-Jacobi approach)
            </summary>
        </member>
        <member name="F:BoSSS.Solution.AdvancedSolvers.PTGconfig.FullSolveOfCutcells">
            <summary>
            If true blocks/cells containing more than one species are completely assigned to low order block solver.
            This hopefully is better than the default approach
            </summary>
        </member>
        <member name="F:BoSSS.Solution.AdvancedSolvers.PTGconfig.MaxKrylovDim">
            <summary>
            number of iterations between restarts
            </summary>
        </member>
        <member name="P:BoSSS.Solution.AdvancedSolvers.PTGconfig.Name">
            <summary>
            
            </summary>
        </member>
        <member name="P:BoSSS.Solution.AdvancedSolvers.PTGconfig.Shortname">
            <summary>
            
            </summary>
        </member>
        <member name="M:BoSSS.Solution.AdvancedSolvers.PTGconfig.CreateInstance(BoSSS.Solution.AdvancedSolvers.MultigridOperator)">
            <summary>
            
            </summary>
        </member>
        <member name="T:BoSSS.Solution.AdvancedSolvers.Schwarz">
            <summary>
            Additive Schwarz method with optional, multiplicative coarse-grid correction.
            </summary>
        </member>
        <member name="T:BoSSS.Solution.AdvancedSolvers.Schwarz.BlockingStrategy">
            <summary>
            Abstract base class, template for different strategies 
            </summary>
        </member>
        <member name="M:BoSSS.Solution.AdvancedSolvers.Schwarz.BlockingStrategy.GetBlocking(BoSSS.Solution.AdvancedSolvers.MultigridOperator)">
            <summary>
            Returns lists which form the blocks of the additive-Schwarz domain decomposition.
            </summary>
            <param name="op"></param>
            <returns>
            - outer enumeration: corresponds to domain-decomposition blocks
            - inner index: indices within the sub-blocks
            - content: local cell indices which form the respective additive-Schwarz block (<see cref="T:BoSSS.Solution.AdvancedSolvers.MultigridOperator"/>
            </returns>
        </member>
        <member name="M:BoSSS.Solution.AdvancedSolvers.Schwarz.BlockingStrategy.GetNoOfBlocks(BoSSS.Solution.AdvancedSolvers.MultigridOperator)">
            <summary>
            Number of blocs returned by <see cref="M:BoSSS.Solution.AdvancedSolvers.Schwarz.BlockingStrategy.GetBlocking(BoSSS.Solution.AdvancedSolvers.MultigridOperator)"/>
            </summary>
        </member>
        <member name="T:BoSSS.Solution.AdvancedSolvers.Schwarz.MultigridBlocks">
            <summary>
            Additive-Schwarz blocks which are formed from cells of coarser multigrid-levels.
            </summary>
        </member>
        <member name="P:BoSSS.Solution.AdvancedSolvers.Schwarz.MultigridBlocks.Depth">
            <summary>
            Number of multigrid levels to step down.
            </summary>
        </member>
        <member name="M:BoSSS.Solution.AdvancedSolvers.Schwarz.MultigridBlocks.GetBlocking(BoSSS.Solution.AdvancedSolvers.MultigridOperator)">
            <summary>
            Returns the multigrid blocking.
            </summary>
        </member>
        <member name="M:BoSSS.Solution.AdvancedSolvers.Schwarz.MultigridBlocks.GetNoOfBlocks(BoSSS.Solution.AdvancedSolvers.MultigridOperator)">
            <summary>
            %
            </summary>
        </member>
        <member name="T:BoSSS.Solution.AdvancedSolvers.Schwarz.METISBlockingStrategy">
            <summary>
            creates a fixed number of blocks by using METIS
            </summary>
        </member>
        <member name="F:BoSSS.Solution.AdvancedSolvers.Schwarz.METISBlockingStrategy.NoOfPartsOnCurrentProcess">
            <summary>
            Number of parts/additive Schwarz blocks on current MPI process (can be different on other processors)
            </summary>
        </member>
        <member name="M:BoSSS.Solution.AdvancedSolvers.Schwarz.METISBlockingStrategy.GetNoOfBlocks(BoSSS.Solution.AdvancedSolvers.MultigridOperator)">
            <summary>
            %
            </summary>
        </member>
        <member name="T:BoSSS.Solution.AdvancedSolvers.Schwarz.SimpleBlocking">
            <summary>
            
            </summary>
        </member>
        <member name="F:BoSSS.Solution.AdvancedSolvers.Schwarz.SimpleBlocking.NoOfPartsPerProcess">
            <summary>
            Number of parts/additive Schwarz blocks on current MPI process.
            </summary>
        </member>
        <member name="T:BoSSS.Solution.AdvancedSolvers.Schwarz.Config">
            <summary>
            
            </summary>
        </member>
        <member name="F:BoSSS.Solution.AdvancedSolvers.Schwarz.Config.UsePMGinBlocks">
            <summary>
            turn P-multigrid for block solvers on/off.
            Not recommended: This may cause bad convergence in the presence of pressure.
            </summary>
        </member>
        <member name="F:BoSSS.Solution.AdvancedSolvers.Schwarz.Config.CoarseSolveOfCutcells">
            <summary>
            Determines, if cutcells are fully assigned (<see cref="P:BoSSS.Solution.AdvancedSolvers.Schwarz.Config.CoarseLowOrder"/>=p) to the coarse solver; only applicable, if p-two-grid is used as block solver
            </summary>
        </member>
        <member name="F:BoSSS.Solution.AdvancedSolvers.Schwarz.Config.pLow">
            <summary>
            DG degree at low order sub-blocks; If p-two-grid is used (<see cref="F:BoSSS.Solution.AdvancedSolvers.Schwarz.Config.UsePMGinBlocks"/>), 
            this degree is the boundary which divides into low order and high order blocks.
            </summary>
        </member>
        <member name="P:BoSSS.Solution.AdvancedSolvers.Schwarz.Config.CoarseLowOrder">
            <summary>
            The maximum order of the coarse system, which is solved by a direct solver.
            NOTE: there is a hack, which consideres <see cref="P:BoSSS.Solution.AdvancedSolvers.Schwarz.Config.CoarseLowOrder"/>-1 for pressure.
            pressure is assumed to be the Dimension-1-th variable
            </summary>
        </member>
        <member name="F:BoSSS.Solution.AdvancedSolvers.Schwarz.Config.m_Overlap">
            <summary>
            <see cref="P:BoSSS.Solution.AdvancedSolvers.Schwarz.Config.Overlap"/>
            </summary>
        </member>
        <member name="P:BoSSS.Solution.AdvancedSolvers.Schwarz.Config.Overlap">
            <summary>
            Overlap of the Schwarz blocks, in number-of-cells.
            - in the case of 0, Additive Schwarz degenerates to Block-Jacobi
            - an overlap of 1 is recommended for most cases
            - a higher overlap may accelerate convergence, but along the MPI boundaries, overlap will always be limited to 1
            - values higher than 2 are currently not supportet (its easy to unlock, but there might be no point
            </summary>
        </member>
        <member name="F:BoSSS.Solution.AdvancedSolvers.Schwarz.Config.EnableOverlapScaling">
            <summary>
            If <see cref="P:BoSSS.Solution.AdvancedSolvers.Schwarz.Config.Overlap"/> > 0, the solution, in cells which are covered by multiple blocks, 
            is scaled in the overlapping region by one over the multiplicity.
            This option might be useful in some applications but may also fail in others:
            - seems to **fail** e.g. if this is used as a preconditioner for PCG (<see cref="T:BoSSS.Solution.AdvancedSolvers.SoftPCG"/>)
            - improves number of iterations if used e.g. as a smoother for <see cref="T:BoSSS.Solution.AdvancedSolvers.OrthonormalizationMultigrid"/>
            </summary>
        </member>
        <member name="F:BoSSS.Solution.AdvancedSolvers.Schwarz.m_BlockingStrategy">
            <summary>
            Strategy for finding the Schwarz blocks.
            </summary>
        </member>
        <member name="P:BoSSS.Solution.AdvancedSolvers.Schwarz.config">
            <summary>
            Solver configuration
            </summary>
        </member>
        <member name="M:BoSSS.Solution.AdvancedSolvers.Schwarz.Init(BoSSS.Solution.AdvancedSolvers.MultigridOperator)">
            <summary>
            ~
            </summary>
        </member>
        <member name="M:BoSSS.Solution.AdvancedSolvers.Schwarz.InitBlockSolver(BoSSS.Solution.AdvancedSolvers.MultigridOperator,System.Int32,BoSSS.Solution.AdvancedSolvers.GridAndDegRestriction)">
            <summary>
            
            </summary>
        </member>
        <member name="F:BoSSS.Solution.AdvancedSolvers.Schwarz.SolutionScaling">
            <summary>
            scaling of blocks in the overlapping regions (<see cref="F:BoSSS.Solution.AdvancedSolvers.Schwarz.Config.EnableOverlapScaling"/>).
            </summary>
        </member>
        <member name="P:BoSSS.Solution.AdvancedSolvers.Schwarz.MtxFull">
            <summary>
            the full operator matrix
            </summary>
        </member>
        <member name="F:BoSSS.Solution.AdvancedSolvers.Schwarz.blockSolvers">
            <summary>
            Linear solver for each block
            </summary>
        </member>
        <member name="F:BoSSS.Solution.AdvancedSolvers.Schwarz.FixedNoOfIterations">
            <summary>
            The fixed number of iteration on this level
            </summary>
        </member>
        <member name="M:BoSSS.Solution.AdvancedSolvers.Schwarz.Solve``2(``0,``1)">
            <summary>
            ~
            </summary>
        </member>
        <member name="P:BoSSS.Solution.AdvancedSolvers.Schwarz.IterationsInNested">
            <summary>
            ~
            </summary>
        </member>
        <member name="P:BoSSS.Solution.AdvancedSolvers.Schwarz.ThisLevelIterations">
            <summary>
            <see cref="P:BoSSS.Solution.AdvancedSolvers.ISolverSmootherTemplate.ThisLevelIterations"/>
            </summary>
        </member>
        <member name="P:BoSSS.Solution.AdvancedSolvers.Schwarz.Converged">
            <summary>
            <see cref="P:BoSSS.Solution.AdvancedSolvers.ISolverSmootherTemplate.Converged"/>
            </summary>
        </member>
        <member name="M:BoSSS.Solution.AdvancedSolvers.Schwarz.ResetStat">
            <summary>
            <see cref="M:BoSSS.Solution.AdvancedSolvers.ISolverSmootherTemplate.ResetStat"/> 
            </summary>
        </member>
        <member name="M:BoSSS.Solution.AdvancedSolvers.Schwarz.DisposeBlockSolver">
            <summary>
            Forget any factorization stored for blocks.
            </summary>
        </member>
        <member name="M:BoSSS.Solution.AdvancedSolvers.Schwarz.Clone">
            <summary>
            ~
            </summary>
        </member>
        <member name="M:BoSSS.Solution.AdvancedSolvers.Schwarz.MatlabDebugging(BoSSS.Solution.AdvancedSolvers.BlockMask[],BoSSS.Solution.AdvancedSolvers.MultigridOperator)">
            <summary>
            This can be used for testing MPI parallel execution
            </summary>
            <param name="BMs">Block Mask for schwarz blocks</param>
            <param name="Mop"></param>
        </member>
        <member name="M:BoSSS.Solution.AdvancedSolvers.Schwarz.Dispose">
            <summary>
            
            </summary>
        </member>
        <member name="M:BoSSS.Solution.AdvancedSolvers.Schwarz.UsedMemory">
            <summary>
            ~
            </summary>
        </member>
        <member name="T:BoSSS.Solution.AdvancedSolvers.SoftGMRES">
            <summary>
            Standard preconditioned GMRES.
            </summary>
        </member>
        <member name="P:BoSSS.Solution.AdvancedSolvers.SoftGMRES.TerminationCriterion">
            <summary>
            ~
            </summary>
        </member>
        <member name="M:BoSSS.Solution.AdvancedSolvers.SoftGMRES.#ctor">
            <summary>
            ctor
            </summary>
        </member>
        <member name="M:BoSSS.Solution.AdvancedSolvers.SoftGMRES.Init(BoSSS.Solution.AdvancedSolvers.IOperatorMappingPair)">
            <summary>
            ~
            </summary>
        </member>
        <member name="M:BoSSS.Solution.AdvancedSolvers.SoftGMRES.Init(BoSSS.Solution.AdvancedSolvers.MultigridOperator)">
            <summary>
            ~
            </summary>
        </member>
        <member name="P:BoSSS.Solution.AdvancedSolvers.SoftGMRES.IterationCallback">
            <summary>
            ~
            </summary>
        </member>
        <member name="F:BoSSS.Solution.AdvancedSolvers.SoftGMRES.MaxKrylovDim">
            <summary>
            number of iterations between restarts
            </summary>
        </member>
        <member name="M:BoSSS.Solution.AdvancedSolvers.SoftGMRES.rotmat(System.Double@,System.Double@,System.Double,System.Double)">
            <summary>
            Compute the Givens rotation matrix parameters for a and b.
            </summary>
        </member>
        <member name="M:BoSSS.Solution.AdvancedSolvers.SoftGMRES.Solve``2(``0,``1)">
            <summary>
            ~
            </summary>
        </member>
        <member name="P:BoSSS.Solution.AdvancedSolvers.SoftGMRES.IterationsInNested">
            <summary>
            ~
            </summary>
        </member>
        <member name="P:BoSSS.Solution.AdvancedSolvers.SoftGMRES.ThisLevelIterations">
            <summary>
            ~
            </summary>
        </member>
        <member name="P:BoSSS.Solution.AdvancedSolvers.SoftGMRES.Converged">
            <summary>
            ~
            </summary>
        </member>
        <member name="T:BoSSS.Solution.AdvancedSolvers.SoftPCG">
            <summary>
            Pre-conditioned (<see cref="P:BoSSS.Solution.AdvancedSolvers.SoftPCG.Precond"/>) conjugate gradient algorithm.
            </summary>
        </member>
        <member name="P:BoSSS.Solution.AdvancedSolvers.SoftPCG.TerminationCriterion">
            <summary>
            ~
            </summary>
        </member>
        <member name="M:BoSSS.Solution.AdvancedSolvers.SoftPCG.#ctor">
            <summary>
            ctor
            </summary>
        </member>
        <member name="P:BoSSS.Solution.AdvancedSolvers.SoftPCG.IterationCallback">
            <summary>
            ~
            </summary>
        </member>
        <member name="P:BoSSS.Solution.AdvancedSolvers.SoftPCG.Precond">
            <summary>
            ~
            </summary>
        </member>
        <member name="M:BoSSS.Solution.AdvancedSolvers.SoftPCG.Solve``2(``0,``1)">
            <summary>
            implementation of the CG algorithm
            </summary>
        </member>
        <member name="M:BoSSS.Solution.AdvancedSolvers.SoftPCG.Init(BoSSS.Solution.AdvancedSolvers.MultigridOperator)">
            <summary>
            ~
            </summary>
        </member>
        <member name="M:BoSSS.Solution.AdvancedSolvers.SoftPCG.Clone">
            <summary>
            ToDo: Cloning of Preconditioner is not supported.
            </summary>
            <returns></returns>
        </member>
        <member name="T:BoSSS.Solution.AdvancedSolvers.SolverFactory">
            <summary>
            Instantiation of nonlinear solvers
            </summary>
        </member>
        <member name="M:BoSSS.Solution.AdvancedSolvers.SolverFactory.#ctor(BoSSS.Solution.Control.NonLinearSolverConfig,BoSSS.Solution.AdvancedSolvers.ISolverFactory)">
            <summary>
            This <see cref="T:BoSSS.Solution.AdvancedSolvers.SolverFactory"/> enables creation of nonlinear solver objects. The configuration <see cref="T:BoSSS.Solution.AdvancedSolvers.ISolverFactory"/> and <see cref="T:BoSSS.Solution.Control.NonLinearSolverConfig"/> can be set in Control-Files (defined in <see cref="T:BoSSS.Solution.Control.AppControl"/>).
            </summary>
        </member>
        <member name="M:BoSSS.Solution.AdvancedSolvers.SolverFactory.#ctor(BoSSS.Solution.Control.NonLinearSolverConfig,BoSSS.Solution.AdvancedSolvers.ISolverFactory,BoSSS.Solution.Queries.QueryHandler)">
            <summary>
            A <see cref="T:BoSSS.Solution.AdvancedSolvers.SolverFactory"/> which supports queries. Provides additional solver specific output: e.g. Used Multigridlevels, etc.
            </summary>
        </member>
        <member name="F:BoSSS.Solution.AdvancedSolvers.SolverFactory.m_qh">
            <summary>
            Enables additional Output via queries
            </summary>
        </member>
        <member name="F:BoSSS.Solution.AdvancedSolvers.SolverFactory.m_lc">
            <summary>
            Internal linear solver configuration. Shall always be != null. And will not be edited within this method!
            </summary>
        </member>
        <member name="F:BoSSS.Solution.AdvancedSolvers.SolverFactory.m_nc">
            <summary>
            Internal nonlinear solver configuration. Shall always be != null. And will not be edited within this method!
            </summary>
        </member>
        <member name="P:BoSSS.Solution.AdvancedSolvers.SolverFactory.Config">
            <summary>
            Internal nonlinear solver configuration. Shall always be != null. And will not be edited within this method!
            </summary>
        </member>
        <member name="M:BoSSS.Solution.AdvancedSolvers.SolverFactory.GenerateNonLin(BoSSS.Solution.AdvancedSolvers.NonlinearSolver@,BoSSS.Solution.AdvancedSolvers.OperatorEvalOrLin,System.Collections.Generic.IEnumerable{BoSSS.Solution.AdvancedSolvers.AggregationGridBasis[]},BoSSS.Solution.AdvancedSolvers.MultigridOperator.ChangeOfBasisConfig[][])">
            <summary>
            This will return which are configured according to <see cref="P:BoSSS.Solution.AdvancedSolvers.SolverFactory.Config"/>
            </summary>
        </member>
        <member name="M:BoSSS.Solution.AdvancedSolvers.SolverFactory.GenerateNonLin_body(BoSSS.Solution.AdvancedSolvers.OperatorEvalOrLin,System.Collections.Generic.IEnumerable{BoSSS.Solution.AdvancedSolvers.AggregationGridBasis[]},BoSSS.Solution.AdvancedSolvers.MultigridOperator.ChangeOfBasisConfig[][])">
            <summary>
            This one is the method-body of <see cref="M:BoSSS.Solution.AdvancedSolvers.SolverFactory.GenerateNonLin(BoSSS.Solution.AdvancedSolvers.NonlinearSolver@,BoSSS.Solution.AdvancedSolvers.OperatorEvalOrLin,System.Collections.Generic.IEnumerable{BoSSS.Solution.AdvancedSolvers.AggregationGridBasis[]},BoSSS.Solution.AdvancedSolvers.MultigridOperator.ChangeOfBasisConfig[][])"/> and shall not be called from the outside. The parameters are mainly handed over to the NonLinearSolver object, which lives in <see cref="T:BoSSS.Solution.AdvancedSolvers.NonlinearSolver"/>.
            </summary>
        </member>
        <member name="T:BoSSS.Solution.AdvancedSolvers.SolverSquence">
            <summary>
            Executes two or more solvers in sequence;
            This could be e.g. some predictor/corrector pair, or some coarse solver/fine smoother pair.
            </summary>
        </member>
        <member name="M:BoSSS.Solution.AdvancedSolvers.SolverSquence.Init(BoSSS.Solution.AdvancedSolvers.MultigridOperator)">
            <summary>
            defines the problem matrix
            </summary>
        </member>
        <member name="F:BoSSS.Solution.AdvancedSolvers.SolverSquence.SolverChain">
            <summary>
            A list of solvers which is used sequentially, after each other.
            </summary>
        </member>
        <member name="M:BoSSS.Solution.AdvancedSolvers.SolverSquence.Residual``3(``0,``1,``2)">
            <summary>
            computes the residual on this level.
            </summary>
        </member>
        <member name="F:BoSSS.Solution.AdvancedSolvers.SolverSquence.Fixedterations">
            <summary>
            How often we cycle over the <see cref="F:BoSSS.Solution.AdvancedSolvers.SolverSquence.SolverChain"/>.
            </summary>
        </member>
        <member name="M:BoSSS.Solution.AdvancedSolvers.SolverSquence.Solve``2(``0,``1)">
            <summary>
            the multigrid iterations for a linear problem
            </summary>
            <param name="xl">on input, the initial guess; on exit, the result of the multigrid iteration</param>
            <param name="bl">the right-hand-side of the problem</param>
        </member>
        <member name="P:BoSSS.Solution.AdvancedSolvers.SolverSquence.IterationsInNested">
            <summary>
            Sum of iterations in entire <see cref="F:BoSSS.Solution.AdvancedSolvers.SolverSquence.SolverChain"/>.
            </summary>
        </member>
        <member name="P:BoSSS.Solution.AdvancedSolvers.SolverSquence.ThisLevelIterations">
            <summary>
            %
            </summary>
        </member>
        <member name="P:BoSSS.Solution.AdvancedSolvers.SolverSquence.Converged">
            <summary>
            Only true, if all solvers in <see cref="F:BoSSS.Solution.AdvancedSolvers.SolverSquence.SolverChain"/> are converged.
            </summary>
        </member>
        <member name="T:BoSSS.Solution.AdvancedSolvers.SparseILU">
            <summary>
            ILU from HYPRE or INTEL library 
            </summary>
        </member>
        <member name="P:BoSSS.Solution.AdvancedSolvers.SparseILU.UsedLibrary">
            <summary>
            Switch between HYPRE and INTEL version
            </summary>
        </member>
        <member name="T:BoSSS.Solution.AdvancedSolvers.ICoordinateMapping">
            <summary>
            Common interface for **coordinate mappings**
            </summary>
        </member>
        <member name="P:BoSSS.Solution.AdvancedSolvers.ICoordinateMapping.NoOfVariables">
            <summary>
            
            </summary>
        </member>
        <member name="M:BoSSS.Solution.AdvancedSolvers.ICoordinateMapping.IsXDGvariable(System.Int32)">
            <summary>
            true, if the <paramref name="iVar"/>-th variable is XDG; otherwise, it must be DG
            </summary>
        </member>
        <member name="M:BoSSS.Solution.AdvancedSolvers.ICoordinateMapping.GetSpeciesIndex(System.Int32,BoSSS.Foundation.XDG.SpeciesId)">
            <summary>
            index of species <paramref name="SId"/> in cell <paramref name="jCell"/>
            </summary>
        </member>
        <member name="M:BoSSS.Solution.AdvancedSolvers.ICoordinateMapping.GetNoOfSpecies(System.Int32)">
            <summary>
            
            </summary>
        </member>
        <member name="P:BoSSS.Solution.AdvancedSolvers.ICoordinateMapping.DgDegree">
            <summary>
            DG polynomial degree (aka order) for each variable
            </summary>
        </member>
        <member name="P:BoSSS.Solution.AdvancedSolvers.ICoordinateMapping.NoOfExternalCells">
            <summary>
            Number of locally stored external cells - no computations are carried out for
            that cells, but their values are needed.
            
            see also <see cref="P:BoSSS.Foundation.Grid.ILogicalCellData.NoOfExternalCells"/>
            </summary>
        </member>
        <member name="M:BoSSS.Solution.AdvancedSolvers.ICoordinateMapping.GetLength(System.Int32)">
            <summary>
            Number of degrees-of-freedom per cell
            </summary>
            <param name="jLoc">local cell index</param>
            <returns></returns>
        </member>
        <member name="M:BoSSS.Solution.AdvancedSolvers.ICoordinateMapping.LocalUniqueIndex(System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
            Mapping from a quadruple (<paramref name="ifld"/>,<paramref name="jCell"/>,<paramref name="iSpec"/>,<paramref name="n"/>) to a 
            MPI-local linear index range 
            </summary>
            <param name="ifld">field/variable index</param>
            <param name="jCell">cell index</param>
            <param name="n">DG/XDG mode index</param>
            <param name="iSpec">XDG species index</param>
            <returns>
            local index, i.e. starting at 0 on all MPI processes 
            </returns>
        </member>
        <member name="M:BoSSS.Solution.AdvancedSolvers.ICoordinateMapping.GlobalUniqueIndex(System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
            MPI-global version of <see cref="M:BoSSS.Solution.AdvancedSolvers.ICoordinateMapping.LocalUniqueIndex(System.Int32,System.Int32,System.Int32,System.Int32)"/>
            </summary>
            <returns>
            A global index, i.e. it a different range, 
            from <see cref="P:ilPSP.IPartitioning.i0"/> (including) to <see cref="P:ilPSP.IPartitioning.iE"/> (excluding),
            on each MPI process.
            </returns>
        </member>
        <member name="M:BoSSS.Solution.AdvancedSolvers.ICoordinateMapping.LocalUniqueIndex(System.Int32,System.Int32,System.Int32)">
            <summary>
            Mapping from a triple (<paramref name="ifld"/>,<paramref name="jCell"/>,<paramref name="n"/>) to a linear index range 
            </summary>
            <param name="ifld">field/variable index</param>
            <param name="jCell">cell index</param>
            <param name="n">DG/XDG mode index</param>
            <returns>
            local index, i.e. starting at 0 on all MPI processes 
            </returns>
        </member>
        <member name="M:BoSSS.Solution.AdvancedSolvers.ICoordinateMapping.GlobalUniqueIndex(System.Int32,System.Int32,System.Int32)">
            <summary>
            MPI-global version of <see cref="M:BoSSS.Solution.AdvancedSolvers.ICoordinateMapping.LocalUniqueIndex(System.Int32,System.Int32,System.Int32)"/>
            </summary>
            <returns>
            A global index, i.e. it a different range, 
            from <see cref="P:ilPSP.IPartitioning.i0"/> (including) to <see cref="P:ilPSP.IPartitioning.iE"/> (excluding),
            on each MPI process.
            </returns>
        </member>
        <member name="P:BoSSS.Solution.AdvancedSolvers.ICoordinateMapping.SpatialDimension">
            <summary>
            1D, 2D or 3D;
            </summary>
        </member>
        <member name="P:BoSSS.Solution.AdvancedSolvers.ICoordinateMapping.NoOfLocalUpdatedCells">
            <summary>
            Alias for <see cref="P:ilPSP.IBlockPartitioning.LocalNoOfBlocks"/>:
            Number of locally updated cells - the cells which are computed on
            this processor (in contrast, see <see cref="P:BoSSS.Solution.AdvancedSolvers.ICoordinateMapping.NoOfExternalCells"/>); 
            see also <see cref="P:BoSSS.Foundation.Grid.ILogicalCellData.NoOfLocalUpdatedCells"/>
            </summary>
        </member>
        <member name="P:BoSSS.Solution.AdvancedSolvers.ICoordinateMapping.LocalCellCount">
            <summary>
            <see cref="P:BoSSS.Solution.AdvancedSolvers.ICoordinateMapping.NoOfExternalCells"/> plus <see cref="P:BoSSS.Solution.AdvancedSolvers.ICoordinateMapping.NoOfLocalUpdatedCells"/>; see also <see cref="P:BoSSS.Foundation.Grid.ILogicalCellData.Count"/>
            </summary>
        </member>
        <member name="P:BoSSS.Solution.AdvancedSolvers.ICoordinateMapping.UsedSpecies">
            <summary>
            All used XDG species.
            Index: enumeration over species.
            </summary>
        </member>
        <member name="T:BoSSS.Solution.AdvancedSolvers.SubBlockSelectorBase">
            <summary>
            This contains a block Selection, which can be specified by the user with the hierachical Selectors: every Matrix is subdivided into cell, variable, species and mode blocks.
            </summary>
        </member>
        <member name="M:BoSSS.Solution.AdvancedSolvers.SubBlockSelectorBase.#ctor(BoSSS.Solution.AdvancedSolvers.ICoordinateMapping)">
            <summary>
            Specifies, which blocks in a matrix shall be selected. Blocksubdivision Default: Selects all blocks.  
            </summary>
            <param name="map"></param>
        </member>
        <member name="F:BoSSS.Solution.AdvancedSolvers.SubBlockSelectorBase.m_CellFilter">
            <summary>
            Selector for cells.
            - 1st argument: local cell index
            - return value: respective DOFs should be included (true) or excluded (false)
            </summary>
        </member>
        <member name="F:BoSSS.Solution.AdvancedSolvers.SubBlockSelectorBase.m_VariableFilter">
            <summary>
            Selector for cells and variables.
            - 1st argument: local cell index
            - 2nd argument: variable index
            - return value: respective DOFs should be included (true) or excluded (false)
            </summary>
        </member>
        <member name="F:BoSSS.Solution.AdvancedSolvers.SubBlockSelectorBase.m_SpeciesFilter">
            <summary>
            Selector for cells and variables and species.
            - 1st argument: cell index
            - 2nd argument: variable index
            - 3rd argument: species index
            - return value: respective DOFs should be included (true) or excluded (false)
            </summary>
        </member>
        <member name="F:BoSSS.Solution.AdvancedSolvers.SubBlockSelectorBase.m_ModeFilter">
            <summary>
            Selector for cells and variables and species.
            - 1st argument: cell index
            - 2nd argument: variable index
            - 3rd argument: species index
            - 4th argument: DG polynomial degree
            - return value: respective DOFs should be included (true) or excluded (false)
            </summary>
        </member>
        <member name="M:BoSSS.Solution.AdvancedSolvers.SubBlockSelectorBase.CellSelector">
            <summary>
            Selects all aggregation cell blocks
            </summary>
            <returns></returns>
        </member>
        <member name="M:BoSSS.Solution.AdvancedSolvers.SubBlockSelectorBase.CellSelector(System.Int32)">
            <summary>
            Selects cell according to global/local cell index
            </summary>
            <param name="CellIdx"></param>
            <returns></returns>
        </member>
        <member name="M:BoSSS.Solution.AdvancedSolvers.SubBlockSelectorBase.CellSelector``1(``0,System.Boolean)">
            <summary>
            Selects List of cells according to global/local index
            </summary>
            <param name="ListOfCellIdx"></param>
            <param name="global"></param>
            <returns></returns>
        </member>
        <member name="M:BoSSS.Solution.AdvancedSolvers.SubBlockSelectorBase.CellSelector(BoSSS.Foundation.Grid.CellMask)">
            <summary>
            Selects all cells in a cell mask.
            </summary>
        </member>
        <member name="M:BoSSS.Solution.AdvancedSolvers.SubBlockSelectorBase.SetVariableSelector">
            <summary>
            Selects all Variable blocks
            </summary>
            <returns></returns>
        </member>
        <member name="M:BoSSS.Solution.AdvancedSolvers.SubBlockSelectorBase.SetVariableSelector(System.Int32[])">
            <summary>
            
            </summary>
        </member>
        <member name="M:BoSSS.Solution.AdvancedSolvers.SubBlockSelectorBase.SetVariableSelector(System.Int32)">
            <summary>
            
            </summary>
        </member>
        <member name="M:BoSSS.Solution.AdvancedSolvers.SubBlockSelectorBase.SetVariableSelector(System.Collections.Generic.IEnumerable{System.Int32})">
            <summary>
            
            </summary>
        </member>
        <member name="M:BoSSS.Solution.AdvancedSolvers.SubBlockSelectorBase.SetSpeciesSelector">
            <summary>
            Selects all species blocks
            </summary>
            <returns></returns>
        </member>
        <member name="M:BoSSS.Solution.AdvancedSolvers.SubBlockSelectorBase.SetSpeciesSelector(BoSSS.Foundation.XDG.SpeciesId)">
            <summary>
            Selects Species by <see cref="T:BoSSS.Foundation.XDG.SpeciesId"/>.
            </summary>
        </member>
        <member name="M:BoSSS.Solution.AdvancedSolvers.SubBlockSelectorBase.SetSpeciesSelector(System.Collections.Generic.IEnumerable{BoSSS.Foundation.XDG.SpeciesId})">
            <summary>
            Selects multiple species by <see cref="T:System.Collections.Generic.IEnumerable`1"/>.
            </summary>
        </member>
        <member name="M:BoSSS.Solution.AdvancedSolvers.SubBlockSelectorBase.SetModeSelector">
            <summary>
            Selects all Modes
            </summary>
            <returns></returns>
        </member>
        <member name="M:BoSSS.Solution.AdvancedSolvers.SubBlockSelectorBase.SetModeSelector(System.Func{System.Int32,System.Boolean})">
            <summary>
            Selects Modes according to instruction.
            </summary>
        </member>
        <member name="M:BoSSS.Solution.AdvancedSolvers.SubBlockSelectorBase.SetModeSelector(System.Func{System.Int32,System.Int32,System.Int32,System.Int32,System.Boolean})">
            <summary>
            Selects Modes according to instruction.
            </summary>
        </member>
        <member name="P:BoSSS.Solution.AdvancedSolvers.SubBlockSelectorBase.CombinedFilter">
            <summary>
            returns a delegate \f$ (j, \gamma, \mathfrak{s}, k ) \mapsto \{ \textrm{true},\textrm{false} \} \f$,
            which determines whether a specific cell-variable-species-mode tuple is in a mapping or not.
            Delegate arguments are:
            - 1st argument: cell index \f$ j \f$
            - 2nd argument: variable index \f$ \gamma \f$
            - 3rd argument: species index \f$ \mathfrak{s} \f$
            - 4th argument: DG polynomial degree \f$ k \f$
            </summary>
        </member>
        <member name="P:BoSSS.Solution.AdvancedSolvers.SubBlockSelectorBase.CellFilter">
            <summary>
            Selector for cells.
            - 1st argument: local cell index
            - return value: respective DOFs should be included (true) or excluded (false)
            </summary>
        </member>
        <member name="P:BoSSS.Solution.AdvancedSolvers.SubBlockSelectorBase.VariableFilter">
            <summary>
            Selector for cells and variables.
            - 1st argument: local cell index
            - 2nd argument: variable index
            - return value: respective DOFs should be included (true) or excluded (false)
            </summary>
        </member>
        <member name="P:BoSSS.Solution.AdvancedSolvers.SubBlockSelectorBase.SpeciesFilter">
            <summary>
            Selector for cells and variables and species.
            - 1st argument: cell index
            - 2nd argument: variable index
            - 3rd argument: species index
            - return value: respective DOFs should be included (true) or excluded (false)
            </summary>
        </member>
        <member name="P:BoSSS.Solution.AdvancedSolvers.SubBlockSelectorBase.ModeFilter">
            <summary>
            Selector for cells and variables and species.
            - 1st argument: cell index
            - 2nd argument: variable index
            - 3rd argument: species index
            - 4th argument: DG polynomial degree
            - return value: respective DOFs should be included (true) or excluded (false)
            </summary>
        </member>
        <member name="P:BoSSS.Solution.AdvancedSolvers.SubBlockSelectorBase.Mapping">
            <summary>
            gets the multigrid operator on which this selector shall work on 
            </summary>
        </member>
        <member name="M:BoSSS.Solution.AdvancedSolvers.extNi0.#ctor(System.Int32,System.Int64,System.Int32,System.Int32)">
            <summary>
            stores offsets and length of a sub block.
            <paramref name="Li0"/> refers to local index of <see cref="T:ilPSP.IBlockPartitioning"/>.
            <paramref name="Gi0"/> refers to global index of <see cref="T:ilPSP.IBlockPartitioning"/>.
            <paramref name="Si0"/> is a local index,
            which numbers the entries of this mask consecutively.
            </summary>
            <param name="Li0">local offset</param>
            <param name="Gi0">global offset</param>
            <param name="Si0">offset relative to mask</param>
            <param name="N">length of block</param>
        </member>
        <member name="T:BoSSS.Solution.AdvancedSolvers.BlockMaskBase">
            <summary>
            This abstract class is the unification of internal and external cell masking.
            Therefore <see cref="P:BoSSS.Solution.AdvancedSolvers.BlockMaskBase.m_NoOfCells"/> and <see cref="P:BoSSS.Solution.AdvancedSolvers.BlockMaskBase.m_CellOffset"/> have to be overridden by inheriting classes.
            There are two inheriting classes: <see cref="T:BoSSS.Solution.AdvancedSolvers.BlockMask.BlockMaskExt"/> and <see cref="T:BoSSS.Solution.AdvancedSolvers.BlockMask.BlockMaskLoc"/>,
            which handle the masking of external cells and internal cells respectively.
            The purpose of this class is to provide the index lists and structs,
            which correspond to underlying selection through the <see cref="T:BoSSS.Solution.AdvancedSolvers.SubBlockSelector"/>.
            </summary>
        </member>
        <member name="T:BoSSS.Solution.AdvancedSolvers.BlockMaskBase.Ni0">
            <summary>
            auxiliary structure. Stores Offsets and Length of subblocks.
            </summary>
        </member>
        <member name="M:BoSSS.Solution.AdvancedSolvers.BlockMaskBase.#ctor(BoSSS.Solution.AdvancedSolvers.SubBlockSelector,MPI.Wrappers.MPI_Comm)">
            <summary>
            Generates Block Mask (index lists) from Sub block selection based on a multigrid mapping. 
            abstract parts are individualized by child classes: <see cref="T:BoSSS.Solution.AdvancedSolvers.BlockMask.BlockMaskLoc"/> and <see cref="T:BoSSS.Solution.AdvancedSolvers.BlockMask.BlockMaskExt"/>
            </summary>
        </member>
        <member name="F:BoSSS.Solution.AdvancedSolvers.BlockMaskBase.m_GlobalMask">
            <summary>
            global indices in this mask
            </summary>
        </member>
        <member name="F:BoSSS.Solution.AdvancedSolvers.BlockMaskBase.m_LocalMask">
            <summary>
            local indices in this mask
            </summary>
        </member>
        <member name="F:BoSSS.Solution.AdvancedSolvers.BlockMaskBase.m_SubBlockMask">
            <summary>
            subblock indices in this mask
            </summary>
        </member>
        <member name="F:BoSSS.Solution.AdvancedSolvers.BlockMaskBase.m_StructuredNi0">
            <summary>
            stores offsets (of local, global and subblock numbering) and lengths of dg blocks
            structure mimics subblock hierarchy:
            - 1st idx : cells
            - 2nd idx : variables
            - 3rd idx : species
            - 4th idx : dg blocks
            content : offset (of local, global and subblock numbering) and length of dg block
            </summary>
        </member>
        <member name="F:BoSSS.Solution.AdvancedSolvers.BlockMaskBase.m_Ni0Len">
            <summary>
            number of DG subblocks in this mask
            </summary>
        </member>
        <member name="F:BoSSS.Solution.AdvancedSolvers.BlockMaskBase.m_MaskLen">
            <summary>
            DOF within this mask
            </summary>
        </member>
        <member name="F:BoSSS.Solution.AdvancedSolvers.BlockMaskBase.m_Ni0">
            <summary>
            same content as <see cref="F:BoSSS.Solution.AdvancedSolvers.BlockMaskBase.m_StructuredNi0"/> but stored in a plain array
            </summary>
        </member>
        <member name="M:BoSSS.Solution.AdvancedSolvers.BlockMaskBase.Ni0Gen">
            <summary>
            Pre generate offsets and lengths for the DG blocks.
            Used in <see cref="M:BoSSS.Solution.AdvancedSolvers.BlockMaskBase.GenerateAllMasks"/>.
            </summary>
            <returns>Ni0 for a default Variable up to the maximal occurring DGdegree</returns>
        </member>
        <member name="M:BoSSS.Solution.AdvancedSolvers.BlockMaskBase.GenerateAllMasks">
            <summary>
            The core of the masking
            Generates index lists and the Ni0-struct-list corresponding to mask
            and is called by the child classes: local and external mask
            Note: the smallest sub blocks are DG blocks!
            </summary>
        </member>
        <member name="M:BoSSS.Solution.AdvancedSolvers.BlockMaskBase.GetLocalidcOfCell(System.Int32)">
            <summary>
            Get the local index list of a cell within this mask
            </summary>
            <param name="iCell"></param>
            <returns></returns>
        </member>
        <member name="M:BoSSS.Solution.AdvancedSolvers.BlockMaskBase.GetGlobalidcOfCell(System.Int32)">
            <summary>
            Get the Global index list of a cell within this mask
            </summary>
            <param name="iCell"></param>
            <returns></returns>
        </member>
        <member name="M:BoSSS.Solution.AdvancedSolvers.BlockMaskBase.GetLengthOfCell(System.Int32)">
            <summary>
            Get the length of a cell within this mask
            </summary>
            <param name="iCell"></param>
            <returns></returns>
        </member>
        <member name="M:BoSSS.Solution.AdvancedSolvers.BlockMaskBase.GetAllSubMatrixCellLength">
            <summary>
            Get Block length for cells in mask
            </summary>
            <returns></returns>
        </member>
        <member name="M:BoSSS.Solution.AdvancedSolvers.BlockMaskBase.GetAllSubMatrixCellOffsets">
            <summary>
            Gets all offsets of subblock index for cellblocks in this mask.
            </summary>
            <returns></returns>
        </member>
        <member name="M:BoSSS.Solution.AdvancedSolvers.BlockMaskBase.GetRelativeSubBlockOffset(System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
            gets sub-block offset relative to the parent cell-block
            </summary>
            <param name="iCell"></param>
            <param name="iVar"></param>
            <param name="iSpc"></param>
            <param name="iMod"></param>
            <returns></returns>
        </member>
        <member name="P:BoSSS.Solution.AdvancedSolvers.BlockMaskBase.NoOfCells">
            <summary>
            Number of cell blocks in mask
            </summary>
        </member>
        <member name="P:BoSSS.Solution.AdvancedSolvers.BlockMaskBase.LocalDOF">
            <summary>
            Returns local number of DOF of Sub Matrix
            </summary>
        </member>
        <member name="T:BoSSS.Solution.AdvancedSolvers.SubBlockSelector">
            <summary>
            Enables the selection of sub blocks within a <see cref="T:BoSSS.Solution.AdvancedSolvers.MultigridMapping"/>,
            which can be specified by the developer.
            There are four selection types: cell, variable, species and dg block selection.
            Default: Selects all blocks.
            </summary>
        </member>
        <member name="M:BoSSS.Solution.AdvancedSolvers.SubBlockSelector.#ctor(BoSSS.Solution.AdvancedSolvers.ICoordinateMapping)">
            <summary>
            ctor
            </summary>
            <param name="map"></param>
        </member>
        <member name="T:BoSSS.Solution.AdvancedSolvers.BlockMask">
            <summary>
            Interface to apply masking onto matrix and vectors according to sub block selection.
            Used in linear solvers (e.g. <see cref="T:BoSSS.Solution.AdvancedSolvers.Schwarz"/>, <see cref="T:BoSSS.Solution.AdvancedSolvers.LevelPmg"/>, etc.).
            </summary>
        </member>
        <member name="T:BoSSS.Solution.AdvancedSolvers.BlockMask.BlockMaskLoc">
            <summary>
            Auxiliary class, provides Local Block masks
            </summary>
        </member>
        <member name="T:BoSSS.Solution.AdvancedSolvers.BlockMask.BlockMaskExt">
            <summary>
            Auxiliary class, provides masking of external cells: overlap that is located on other MPI processes
            </summary>
        </member>
        <member name="M:BoSSS.Solution.AdvancedSolvers.BlockMask.BlockMaskExt.GetLocalLength_Ext(BoSSS.Solution.AdvancedSolvers.ICoordinateMapping)">
            <summary>
            Gets DOF of ghost cells available on this proc
            </summary>
            <returns>DOF of ghost cells available on this proc
            </returns>
        </member>
        <member name="P:BoSSS.Solution.AdvancedSolvers.BlockMask.BlockMaskExt.m_LocalLength">
            <summary>
            These are the DOF of external ghost cells available on this proc
            Note: this is method requires MPI communication
            and thus must be called on ALL procs
            </summary>
        </member>
        <member name="M:BoSSS.Solution.AdvancedSolvers.BlockMask.#ctor(BoSSS.Solution.AdvancedSolvers.SubBlockSelector,ilPSP.LinSolvers.BlockMsrMatrix)">
            <summary>
            generates a masking of subblocks within a <see cref="T:BoSSS.Solution.AdvancedSolvers.MultigridMapping"/> according to <see cref="T:BoSSS.Solution.AdvancedSolvers.SubBlockSelector"/> <paramref name="sbs"/>
            enables applying mask onto matrices and vectors, which comply with this <see cref="T:BoSSS.Solution.AdvancedSolvers.MultigridMapping"/>.
            (e.g. sub matrix generation, sub vector extraction, etc.).
            The smallest unit are dg blocks.
            The masking operates on local blocks available on this proc per default,
            which can be exceeded to external blocks by providing external rows: <paramref name="ExtRows"/>.
            Ghost cells (covert by <see cref="P:BoSSS.Foundation.Grid.ILogicalCellData.NoOfExternalCells"/>) can be acquired by <see cref="M:BoSSS.Solution.AdvancedSolvers.BlockMask.GetAllExternalRows(BoSSS.Solution.AdvancedSolvers.MultigridMapping,ilPSP.LinSolvers.BlockMsrMatrix)"/>.
            </summary>
            <param name="sbs">sub block selection defined by dev</param>
            <param name="ExtRows">external rows collected from other MPI-processes on this proc</param>
        </member>
        <member name="P:BoSSS.Solution.AdvancedSolvers.BlockMask.IsEmpty">
            <summary>
            true if no elements are selected;
            Typically some phatological use case, e.g. very coarse meshes
            </summary>
        </member>
        <member name="F:BoSSS.Solution.AdvancedSolvers.BlockMask.BMLoc">
            <summary>
            Block mask of local entires yield by <see cref="T:BoSSS.Solution.AdvancedSolvers.BlockMask.BlockMaskLoc"/>
            </summary>
        </member>
        <member name="F:BoSSS.Solution.AdvancedSolvers.BlockMask.BMExt">
            <summary>
            Block mask of external entires yield by <see cref="T:BoSSS.Solution.AdvancedSolvers.BlockMask.BlockMaskExt"/>
            </summary>
        </member>
        <member name="F:BoSSS.Solution.AdvancedSolvers.BlockMask.SubMatrixOffsets">
            <summary>
            collected sub matrix offsets of <see cref="F:BoSSS.Solution.AdvancedSolvers.BlockMask.BMLoc"/> and <see cref="F:BoSSS.Solution.AdvancedSolvers.BlockMask.BMExt"/>
            </summary>
        </member>
        <member name="F:BoSSS.Solution.AdvancedSolvers.BlockMask.SubMatrixLen">
            <summary>
            collected sub matrix lengths of <see cref="F:BoSSS.Solution.AdvancedSolvers.BlockMask.BMLoc"/> and <see cref="F:BoSSS.Solution.AdvancedSolvers.BlockMask.BMExt"/>
            </summary>
        </member>
        <member name="F:BoSSS.Solution.AdvancedSolvers.BlockMask.m_ExchangeExternalRows">
            <summary>
            inter-process communication of matrix rows
            </summary>
        </member>
        <member name="F:BoSSS.Solution.AdvancedSolvers.BlockMask.StructuredNi0">
            <summary>
            structured Ni0 of <see cref="F:BoSSS.Solution.AdvancedSolvers.BlockMask.BMLoc"/> and <see cref="F:BoSSS.Solution.AdvancedSolvers.BlockMask.BMExt"/>
            </summary>
        </member>
        <member name="F:BoSSS.Solution.AdvancedSolvers.BlockMask.m_map">
            <summary>
            <see cref="T:BoSSS.Solution.AdvancedSolvers.ICoordinateMapping"/>, which this mask is based upon
            </summary>
        </member>
        <member name="F:BoSSS.Solution.AdvancedSolvers.BlockMask.m_ExtRows">
            <summary>
            external rows, which correspond to ghost cells, overgiven in cctor
            </summary>
        </member>
        <member name="P:BoSSS.Solution.AdvancedSolvers.BlockMask.NoOfMaskedCells">
            <summary>
            Gets number of blocks/cells covert by mask
            </summary>
        </member>
        <member name="P:BoSSS.Solution.AdvancedSolvers.BlockMask.NoOfMaskedRows">
            <summary>
            Gets number of rows covert by mask
            </summary>
        </member>
        <member name="M:BoSSS.Solution.AdvancedSolvers.BlockMask.GetSubBlockMatrix_MpiSelf(ilPSP.LinSolvers.BlockMsrMatrix)">
            <summary>
            If you just want to get the <see cref="T:ilPSP.LinSolvers.BlockMsrMatrix"/>, which corresponds to this <see cref="T:BoSSS.Solution.AdvancedSolvers.BlockMask"/>.
            This is the method to choose!
            </summary>
            <returns>sub-matrix on <see cref="P:MPI.Wrappers.IMPI_CommConstants.SELF"/></returns>
        </member>
        <member name="M:BoSSS.Solution.AdvancedSolvers.BlockMask.GetSubBlockMatrix(ilPSP.LinSolvers.BlockMsrMatrix,MPI.Wrappers.MPI_Comm)">
            <summary>
            If you just want to get the <see cref="T:ilPSP.LinSolvers.BlockMsrMatrix"/>, which corresponds to this <see cref="T:BoSSS.Solution.AdvancedSolvers.BlockMask"/>.
            This is the method to choose! In addition, MPI communicator can be defined via <paramref name="comm"/>.
            </summary>
            <returns>sub-matrix on <paramref name="comm"/></returns>
        </member>
        <member name="M:BoSSS.Solution.AdvancedSolvers.BlockMask.GetSubBlockMatrix(ilPSP.LinSolvers.BlockMsrMatrix,BoSSS.Solution.AdvancedSolvers.BlockMask,MPI.Wrappers.MPI_Comm)">
            <summary>
            If you just want to get the <see cref="T:ilPSP.LinSolvers.BlockMsrMatrix"/>, which corresponds to this <see cref="T:BoSSS.Solution.AdvancedSolvers.BlockMask"/>.
            This is the method to choose! In addition, MPI communicator can be defined via <paramref name="comm"/>.
            </summary>
            <returns>sub-matrix on <paramref name="comm"/></returns>
        </member>
        <member name="M:BoSSS.Solution.AdvancedSolvers.BlockMask.GetDiagonalBlocks(ilPSP.LinSolvers.BlockMsrMatrix,System.Boolean,System.Boolean)">
            <summary>
            Get array of diagonal cell-blocks covert by <see cref="T:BoSSS.Solution.AdvancedSolvers.BlockMask"/>. With the ignore flags,
            coupling blocks can be left out (e.g. blocks containing level-set).
            - index i: block of i-th cell within mask (note: if some cell selection specified, i corresponds not to local cell index)
            - content: matrix corresponding to masking
            </summary>
            <param name="source">matrix to apply masking to</param>
            <param name="ignoreVarCoupling">flag to ignore variable coupling</param>
            <param name="ignoreSpecCoupling">flag to ignore species coupling</param>
            <returns></returns>
        </member>
        <member name="M:BoSSS.Solution.AdvancedSolvers.BlockMask.GetSubBlockMatrix(ilPSP.LinSolvers.BlockMsrMatrix,System.Boolean,System.Boolean,System.Boolean)">
            <summary>
            Get SubMatrix corresponding to this <see cref="T:BoSSS.Solution.AdvancedSolvers.BlockMask"/>.
            With the ignore flags, coupling blocks can be left out (e.g. blocks containing level-set).
            If <paramref name="ignoreCellCoupling"/> is set true, only diagonal blocks are considered.
            Probably slower than <see cref="M:BoSSS.Solution.AdvancedSolvers.BlockMask.GetSubBlockMatrix_MpiSelf(ilPSP.LinSolvers.BlockMsrMatrix)"/>.
            </summary>
            <remarks>
            If you are using <paramref name="ignoreCellCoupling"/>, you may dismiss coupling with other cells.
            By comparison to variables, whose ordering is fixed in the mapping, this does not hold for species.
            E.g. iSpc=0 is not corresponding to the same species within every cell
            </remarks>
            <param name="source">matrix to apply masking to</param>
            <param name="ignoreCellCoupling">flag to ignore cell coupling</param>
            <param name="ignoreVarCoupling">flag to ignore variable coupling</param>
            <param name="ignoreSpecCoupling">flag to ignore species coupling</param>
            <returns>sub block matrix</returns>
        </member>
        <member name="M:BoSSS.Solution.AdvancedSolvers.BlockMask.AccSubVec``2(``1,``0)">
            <summary>
            accumulates the <paramref name="subVector"/>, which correspond to <see cref="T:BoSSS.Solution.AdvancedSolvers.BlockMask"/>, back to the <paramref name="fullVector"/>.
            </summary>
            <typeparam name="V"></typeparam>
            <typeparam name="W"></typeparam>
            <param name="fullVector">output, unmasked vector</param>
            <param name="subVector">input, masked vector</param>
        </member>
        <member name="M:BoSSS.Solution.AdvancedSolvers.BlockMask.AccSubVec``3(``2,``1,``0)">
            <summary>
            accumulates the <paramref name="subVector"/>, which correspond to <see cref="T:BoSSS.Solution.AdvancedSolvers.BlockMask"/>,
            back to the unmasked full vector.
            Entries of <paramref name="subVector"/> are distributed to the local (<paramref name="locFullVector"/>)
            and external (<paramref name="extFullVector"/>) part of the unmasked vector.
            </summary>
            <typeparam name="U"></typeparam>
            <typeparam name="V"></typeparam>
            <typeparam name="W"></typeparam>
            <param name="subVector">input, sub vector to accumulate</param>
            <param name="extFullVector">output, external part of unmasked vector</param>
            <param name="locFullVector">output, local part of unmasked vector</param>
        </member>
        <member name="M:BoSSS.Solution.AdvancedSolvers.BlockMask.AccSubVecOfCell``2(``1,System.Int32,``0)">
            <summary>
            accumulates masked vector <paramref name="subVector"/>
            of cell block <paramref name="iBlock"/>
            back to the full vector <paramref name="fullVector"/>. 
            <paramref name="iBlock"/> is the consecutive index of cellblocks,
            which are yield by <see cref="M:BoSSS.Solution.AdvancedSolvers.BlockMask.GetDiagonalBlocks(ilPSP.LinSolvers.BlockMsrMatrix,System.Boolean,System.Boolean)"/>.
            note: if some cell selection specified, i corresponds not to local cell index
            </summary>
            <typeparam name="V"></typeparam>
            <typeparam name="W"></typeparam>
            <param name="fullVector">output, unmaksed vector</param>
            <param name="subVector">input, masked vector</param>
            <param name="iBlock">cell-block index</param>
        </member>
        <member name="M:BoSSS.Solution.AdvancedSolvers.BlockMask.GetSubVecOfCell``1(``0,System.Int32)">
            <summary>
            returns the sub-vector of <paramref name="fullVector"/>
            corresponding to <see cref="T:BoSSS.Solution.AdvancedSolvers.BlockMask"/> of cell block <paramref name="iBlock"/>.
            <paramref name="iBlock"/> is the consecutive index of cell-blocks,
            which are yield by <see cref="M:BoSSS.Solution.AdvancedSolvers.BlockMask.GetDiagonalBlocks(ilPSP.LinSolvers.BlockMsrMatrix,System.Boolean,System.Boolean)"/>.
            note: if some cell selection specified, i corresponds not to local cell index
            </summary>
            <param name="fullVector">input, unmasked vector</param>
            <param name="iBlock">cell-block index</param>
            <returns>sub-vector of cell block <paramref name="iBlock"/></returns>
        </member>
        <member name="M:BoSSS.Solution.AdvancedSolvers.BlockMask.GetSubVec``1(``0)">
            <summary>
            returns the subvector of <paramref name="fullVector"/>
            corresponding to <see cref="T:BoSSS.Solution.AdvancedSolvers.BlockMask"/>.
            </summary>
            <param name="fullVector">input, unmasked vector</param>
        </member>
        <member name="M:BoSSS.Solution.AdvancedSolvers.BlockMask.GetSubVec(System.Collections.Generic.IList{System.Double},System.Collections.Generic.IList{System.Double})">
            <summary>
            returns the subvector
            corresponding to <see cref="T:BoSSS.Solution.AdvancedSolvers.BlockMask"/>.
            Entries of subvector are taken from the local (<paramref name="locfullVector"/>)
            and external (<paramref name="extFullVector"/>) part of the unmasked vector.
            </summary>
            <param name="extFullVector">input, external part of unmasked vector</param>
            <param name="locfullVector">input, local part of unmasked vector</param>
            <returns></returns>
        </member>
        <member name="M:BoSSS.Solution.AdvancedSolvers.BlockMask.GetAllExternalRows(BoSSS.Solution.AdvancedSolvers.MultigridMapping,ilPSP.LinSolvers.BlockMsrMatrix)">
            <summary>
            returns all external rows of <paramref name="M"/>
            corresponding to ghost cells of <paramref name="map"/>,
            which are located on other MPI-ranks.
            </summary>
            <param name="map">Multigrid mapping</param>
            <param name="M">matrix distributed according to <paramref name="map"/></param>
            <returns></returns>
            <remarks>
            Exchange of matrix rows between MPI processors is implemented using multiplication with a permutation matrix.
            In this way, the MPI-communication routines of <see cref="M:ilPSP.LinSolvers.BlockMsrMatrix.Multiply(ilPSP.LinSolvers.BlockMsrMatrix,ilPSP.LinSolvers.BlockMsrMatrix)"/> can be re-used.
            </remarks>
        </member>
        <member name="M:BoSSS.Solution.AdvancedSolvers.BlockMask.GetLocalAndExternalDOF(BoSSS.Solution.AdvancedSolvers.ICoordinateMapping)">
            <summary>
            
            </summary>
        </member>
        <member name="M:BoSSS.Solution.AdvancedSolvers.BlockMask.GetFullSubBlocks(ilPSP.LinSolvers.BlockMsrMatrix,System.Boolean,System.Boolean)">
            <summary>
            Extracts blocks from matrix <paramref name="source"/>, i.e. one block per cell and the coupling between these cells.
            This might only work for local available cells
            </summary>
        </member>
        <member name="P:BoSSS.Solution.AdvancedSolvers.BlockMask.GlobalIndices">
            <summary>
            global (i.e. across all MPI processors) indices of vector entries, resp. matrix rows and columns to select.
            </summary>
        </member>
        <member name="P:BoSSS.Solution.AdvancedSolvers.BlockMask.LocalIndices">
            <summary>
            local (i.e. valid only on current MPI processor) indices of vector entries, resp. matrix rows and columns to select.
            </summary>
        </member>
        <member name="P:BoSSS.Solution.AdvancedSolvers.BlockMask.LocalLength">
            <summary>
            number of indices on the current processor
            </summary>
        </member>
        <member name="P:BoSSS.Solution.AdvancedSolvers.BlockMask.GlobalIndices_Internal">
            <summary>
            This is provided for testing or if you know what you are doing!
            </summary>
        </member>
        <member name="P:BoSSS.Solution.AdvancedSolvers.BlockMask.GlobalIndices_External">
            <summary>
            This is provided for testing or if you know what you are doing!
            </summary>
        </member>
        <member name="T:BoSSS.Solution.AdvancedSolvers.UniSolver">
            <summary>
            Driver routines for the solver framework
            </summary>
        </member>
        <member name="M:BoSSS.Solution.AdvancedSolvers.UniSolver.MatrixAssembler.AssembleMatrix(ilPSP.LinSolvers.BlockMsrMatrix@,System.Double[]@,ilPSP.LinSolvers.BlockMsrMatrix@,BoSSS.Foundation.DGField[],System.Boolean,BoSSS.Foundation.ISpatialOperator@)">
            <summary>
            Implementation of <see cref="T:BoSSS.Solution.AdvancedSolvers.OperatorEvalOrLin"/>
            </summary>
        </member>
        <member name="F:BoSSS.Solution.AdvancedSolvers.UniSolver.NonXDG_LsTrk">
            <summary>
            Freak API:
            For the very special case, that an XDG-computation should be performed on DG fields (there are some examples),
            this can be used to tell the <see cref="M:BoSSS.Solution.AdvancedSolvers.UniSolver.Solve(BoSSS.Foundation.ISpatialOperator,BoSSS.Foundation.CoordinateMapping,BoSSS.Foundation.CoordinateMapping,BoSSS.Solution.AdvancedSolvers.MultigridOperator.ChangeOfBasisConfig[][],BoSSS.Solution.Control.NonLinearSolverConfig,BoSSS.Solution.AdvancedSolvers.ISolverFactory,BoSSS.Foundation.Grid.Aggregation.AggregationGridData[],System.Boolean,BoSSS.Solution.Queries.QueryHandler)"/>-routine which Tracker to use.
            This is an **intentionally bad, but good design, because freak cases should never be allowed to spoil good APIs.** 
            </summary>
        </member>
        <member name="M:BoSSS.Solution.AdvancedSolvers.UniSolver.Solve(BoSSS.Foundation.ISpatialOperator,BoSSS.Foundation.CoordinateMapping,BoSSS.Foundation.CoordinateMapping,BoSSS.Solution.AdvancedSolvers.MultigridOperator.ChangeOfBasisConfig[][],BoSSS.Solution.Control.NonLinearSolverConfig,BoSSS.Solution.AdvancedSolvers.ISolverFactory,BoSSS.Foundation.Grid.Aggregation.AggregationGridData[],System.Boolean,BoSSS.Solution.Queries.QueryHandler)">
            <summary>
            General-Purpose driver Routine for performing a steady-state solution of a PDE defined through some operator
            </summary>
            <param name="op">
            The spatial operator for the PDE to be solved (we solve `$ \mathrm(op)(U) = 0 `$, where `$ U `$ stands for <paramref name="Solution"/>).
            In order to obtain a non-zero solution, this must typically contain some source terms or inhomogeneous boundary conditions.
            </param>
            <param name="Solution">
            DG fields to store the solution.
            </param>
            <param name="nsc">
            - configuration of the nonlinear solver 
            - if null, an default solver configuration is used
            </param>
            <param name="lsc">
            - configuration of the linear solver 
            - if null, an default solver configuration is used 
            </param>
            <param name="MultigridSequence">
            Multigrid sequence/hierarchy on which a multigrid solver should operate;
            Providing this does not guarantee that a multigrid solver is used, this also depends on the other solver settings.
            </param>
            <param name="verbose">
            - If true, Writes a lot of logging information
            - If false, console output should be relatively less
            </param>
            <param name="MgConfig">
            Provisional: will be integrated into the <see cref="T:BoSSS.Foundation.ISpatialOperator"/> at some point.
            </param>
            <param name="queryHandler">
            if provided, logging of solver statistics to the unified query table used with the BoSSS database
            </param>
            <param name="optRHS">
            An optional right-hand-side for the system; per Definition, it is independent of the solution.
            If provided, the mapping must be partition-equal (<see cref="M:ilPSP.Partitioning_Extensions.EqualsPartition(ilPSP.IPartitioning,ilPSP.IPartitioning)"/>) to <paramref name="Solution"/>
            </param>
            <returns>
            true on solver success
            </returns>
        </member>
        <member name="M:BoSSS.Solution.AdvancedSolvers.UniSolver.OperatorAnalysis(BoSSS.Foundation.ISpatialOperator,BoSSS.Foundation.CoordinateMapping,BoSSS.Solution.AdvancedSolvers.MultigridOperator.ChangeOfBasisConfig[][])">
            <summary>
            Easy-to-use driver routine for operator analysis
            </summary>
            <param name="op"></param>
            <param name="Mapping">
            Current Solution resp. solution approximation;
            Any matrix analysis is performed at this linearization point.
            </param>
            <param name="MgConfig">
            provisional; not that the block preconditioning configured here has huge effects on the condition number.
            </param>
            <returns></returns>
            <seealso cref="M:BoSSS.Solution.Application`1.OperatorAnalysis"/>
        </member>
        <member name="M:BoSSS.Solution.AdvancedSolvers.UniSolver.GetMultigridOperator(BoSSS.Foundation.ISpatialOperator,BoSSS.Foundation.CoordinateMapping,BoSSS.Solution.AdvancedSolvers.MultigridOperator.ChangeOfBasisConfig[][])">
            <summary>
            Easy-to-use driver routine to obtain the multigrid-operator object
            </summary>
            <param name="op"></param>
            <param name="Mapping">
            Current Solution resp. solution approximation;
            Any matrix analysis is performed at this linearization point.
            </param>
            <param name="MgConfig">
            provisional; note that the block preconditioning configured here has huge effects on the condition number.
            </param>
            <returns></returns>
        </member>
        <member name="M:BoSSS.Solution.AdvancedSolvers.UniSolver.GetMatrix(BoSSS.Foundation.ISpatialOperator,BoSSS.Foundation.CoordinateMapping,BoSSS.Solution.AdvancedSolvers.MultigridOperator.ChangeOfBasisConfig[][])">
            <summary>
            Easy-to-use driver routine to obtain the block-preconditioned operator matrix.
            </summary>
            <param name="op"></param>
            <param name="Mapping">
            Current Solution resp. solution approximation;
            Any matrix analysis is performed at this linearization point.
            </param>
            <param name="MgConfig">
            provisional; note that the block preconditioning configured here has huge effects on the condition number.
            </param>
            <returns></returns>
        </member>
        <member name="M:BoSSS.Solution.AdvancedSolvers.Utils.arnoldi(System.Double[][]@,System.Double[0:,0:]@,System.Int32@,ilPSP.LinSolvers.MsrMatrix,System.Double[],System.Int32,System.Boolean)">
            <summary>
            Arnoldi iteration 
            </summary>
            <param name="V">Output: Arnoldi vectors</param>
            <param name="H">Output: </param>
            <param name="kact">Output:</param>
            <param name="A">Input: (n-by-n) the matrix </param>
            <param name="v0">Input: n-vector</param>
            <param name="k">Input: number of Arnoldi steps requested</param>
            <param name="reorth">Input: (optional) set to 1 for reorthogonalization, (default), set to any other value to switch it off</param>
            <remarks>
            (c) Ren-Cang Li, rcli@uta.edu,  06/16/07
            </remarks>
        </member>
        <member name="T:BoSSS.Solution.AdvancedSolvers.XdgAggregationBasis">
            <summary>
            XDG basis on an aggregation mesh
            </summary>
            <remarks>
            See: 
            Kummer, F., Weber, J., and Smuda, M. (2021);
            BoSSS: A package for multigrid extended discontinuous Galerkin methods,
            Computers and Mathematics with Applications, 81:237–257.
            </remarks>
        </member>
        <member name="P:BoSSS.Solution.AdvancedSolvers.XdgAggregationBasis.XDGBasis">
            <summary>
            XDG basis on original grid
            </summary>
        </member>
        <member name="M:BoSSS.Solution.AdvancedSolvers.XdgAggregationBasis.#ctor(BoSSS.Foundation.XDG.XDGBasis,BoSSS.Solution.AdvancedSolvers.XdgAggregationBasis,BoSSS.Foundation.Grid.Aggregation.AggregationGridData,ilPSP.MultidimensionalArray[])">
            <summary>
            ctor.
            </summary>
            <param name="xb">
            XDG basis on original grid
            </param>
            <param name="parentBasis">
            basis on parent grid
            </param>
            <param name="ag">
            aggregation grid level.
            </param>
            <param name="inj">
            injection operators.
            </param>
        </member>
        <member name="M:BoSSS.Solution.AdvancedSolvers.XdgAggregationBasis.Update(BoSSS.Foundation.XDG.MultiphaseCellAgglomerator)">
            <summary>
            Update the basis to comply with the agglomeration
            </summary>
            <remarks>
            See at Figure 6 in: 
            Kummer, F., Weber, J., and Smuda, M. (2021);
            BoSSS: A package for multigrid extended discontinuous Galerkin methods,
            Computers and Mathematics with Applications, 81:237–257.
            </remarks>
        </member>
        <member name="P:BoSSS.Solution.AdvancedSolvers.XdgAggregationBasis.UsedSpecies">
            <summary>
            All used species.
            Index: enumeration over species.
            </summary>
        </member>
        <member name="M:BoSSS.Solution.AdvancedSolvers.XdgAggregationBasis.UpdateSpeciesMapping(BoSSS.Foundation.XDG.MultiphaseCellAgglomerator)">
            <summary>
            defines how species in the agglomerated cells
            map to species in the base grid cells.
            </summary>
        </member>
        <member name="F:BoSSS.Solution.AdvancedSolvers.XdgAggregationBasis.NoOfSpecies">
            <summary>
            Number of species present (i.e. with non-zero measure) per composite cell; 
             - index: composite cell index;
            </summary>
        </member>
        <member name="F:BoSSS.Solution.AdvancedSolvers.XdgAggregationBasis.SpeciesIndexMapping">
            <summary>
            Mapping from species indices in composite/aggregate cells to species index in base grid.
             - 1st index: composite cell index;
             - 2nd index: species index in composite/aggregate cell.
             - 3rd index: enumeration of base grid cells in the composite cell.
            </summary>
            <remarks>
            If (<see cref="F:BoSSS.Solution.AdvancedSolvers.XdgAggregationBasis.SpeciesIndexMapping"/>[j] == null), this indicates that 
            the single-phase implementation in underlying class should be used.
            </remarks>
        </member>
        <member name="F:BoSSS.Solution.AdvancedSolvers.XdgAggregationBasis.AggCellsSpecies">
            <summary>
            species in the composite/aggregate cells;<br/>
             - 1st index: aggregate cell index.
             - 2nd index: species index in the composite/aggregate cell.
            </summary>
        </member>
        <member name="M:BoSSS.Solution.AdvancedSolvers.XdgAggregationBasis.GetSpeciesIndex(System.Int32,BoSSS.Foundation.XDG.SpeciesId)">
            <summary>
            Returns the species index of species <paramref name="spid"/> in
            composite/aggregate cell <paramref name="jAgg"/> .
            </summary>
        </member>
        <member name="M:BoSSS.Solution.AdvancedSolvers.XdgAggregationBasis.GetNoOfSpecies(System.Int32)">
            <summary>
            Number of species in composite/aggregate cell <paramref name="jAgg"/>.
            </summary>
        </member>
        <member name="P:BoSSS.Solution.AdvancedSolvers.XdgAggregationBasis.LocalDim">
            <summary>
            local vector-space dimension.
            </summary>
        </member>
        <member name="M:BoSSS.Solution.AdvancedSolvers.XdgAggregationBasis.GetLength(System.Int32,System.Int32)">
            <summary>
            Number of DOFs in all present species (i.e. species has a non-zero measure).
            </summary>
        </member>
        <member name="M:BoSSS.Solution.AdvancedSolvers.XdgAggregationBasis.N_Murks(System.Int32,System.Int32,System.Int32)">
            <summary>
            for XDG, the cell mode index <paramref name="n"/> may not be equal
            in the full and the aggregated grid. This method performs the transformation.
            </summary>
        </member>
        <member name="T:BoSSS.Solution.Control.LinearSolverCode">
            <summary>
            Abbreviations for various pre-defined solver configurations (objects implementing <see cref="T:BoSSS.Solution.AdvancedSolvers.ISolverFactory"/>)
            to be used with the 'convenience method' <see cref="M:BoSSS.Solution.Control.SolverConfigFactory.GetConfig(BoSSS.Solution.Control.LinearSolverCode)"/>.
            </summary>
        </member>
        <member name="F:BoSSS.Solution.Control.LinearSolverCode.automatic">
            <summary>
            Automatic choose of linear solver depending on nonlinear solver, problem size, etc.
            </summary>
        </member>
        <member name="F:BoSSS.Solution.Control.LinearSolverCode.direct_mumps">
            <summary>
            Direct solver (<see cref="N:ilPSP.LinSolvers.MUMPS"/>) without any pre-processing of the matrix.
            </summary>
        </member>
        <member name="F:BoSSS.Solution.Control.LinearSolverCode.direct_pardiso">
            <summary>
            Direct solver (<see cref="T:ilPSP.LinSolvers.PARDISO.PARDISOSolver"/>) without any pre-processing of the matrix.
            </summary>
        </member>
        <member name="F:BoSSS.Solution.Control.LinearSolverCode.exp_Kcycle_schwarz">
            <summary>
            Multiple levels of additive Schwarz, in a Krylov multi-grid cycle.
            </summary>
        </member>
        <member name="F:BoSSS.Solution.Control.LinearSolverCode.exp_gmres_levelpmg">
            <summary>
            GMRES with p-multigrid on the same mesh level; direct solver is used for lowest polynomial level
            </summary>
        </member>
        <member name="F:BoSSS.Solution.Control.LinearSolverCode.exp_Kcycle_ILU">
            <summary>
            a k-cycle (i.e. a tree of <see cref="T:BoSSS.Solution.AdvancedSolvers.OrthonormalizationMultigrid"/> solvers), with ILU-preconditioner (<see cref="T:BoSSS.Solution.AdvancedSolvers.CellILU"/>) at each level
            </summary>
        </member>
        <member name="F:BoSSS.Solution.Control.LinearSolverCode.pMultigrid">
            <summary>
            p-Multigrid (i.e. multigrid over DG polynomial degree), <see cref="T:BoSSS.Solution.AdvancedSolvers.PmgConfig"/>
            </summary>
        </member>
        <member name="T:BoSSS.Solution.Control.SolverConfigFactory">
            <summary>
            Extension methods
            </summary>
        </member>
        <member name="M:BoSSS.Solution.Control.SolverConfigFactory.GetConfig(BoSSS.Solution.Control.LinearSolverCode)">
            <summary>
            Convenience method: turns a simple configuration code (<paramref name="config"/>)
            into a full-fledged solver configuration.
            </summary>
        </member>
        <member name="F:BoSSS.Solution.Control.LinearSolverMode.Solve">
            <summary>
            Standard Mode, perform the simulation (solve the linear system)
            </summary>
        </member>
        <member name="F:BoSSS.Solution.Control.LinearSolverMode.SpectralAnalysis">
            <summary>
            Set RHS to zero and examine the error spectrum before and after solving
            </summary>
        </member>
        <member name="F:BoSSS.Solution.Control.NonLinearSolverCode.Picard">
            <summary>
            The bald guy from the Enterprise.
            Picard fixpoint solver (<see cref="T:BoSSS.Solution.AdvancedSolvers.FixpointIterator"/>) with linear solver (<see cref="T:BoSSS.Solution.Control.LinearSolverCode"/>) for the linearized equation system
            </summary>
        </member>
        <member name="F:BoSSS.Solution.Control.NonLinearSolverCode.Newton">
            <summary>
            Newtons method (<see cref="T:BoSSS.Solution.AdvancedSolvers.Newton"/>) with linear solver (<see cref="T:BoSSS.Solution.Control.LinearSolverCode"/>) used to approximate the inverse of the jacobian with the inverse operator matrix. 
            </summary>
        </member>
        <member name="T:BoSSS.Solution.Control.NonLinearSolverConfig">
            <summary>
            User-Options for nonlinear solver configuration; 
            </summary>
        </member>
        <member name="F:BoSSS.Solution.Control.NonLinearSolverConfig.verbose">
            <summary>
            This will print out more information about iterations.
            </summary>
        </member>
        <member name="F:BoSSS.Solution.Control.NonLinearSolverConfig.MaxSolverIterations">
            <summary>
            If iterative solvers are used, the maximum number of iterations.
            </summary>
        </member>
        <member name="F:BoSSS.Solution.Control.NonLinearSolverConfig.MinSolverIterations">
            <summary>
            If iterative solvers are used, the minimum number of iterations.
            </summary>
        </member>
        <member name="F:BoSSS.Solution.Control.NonLinearSolverConfig.ConvergenceCriterion">
            <summary>
            Convergence criterion for nonlinear solver.
            Setting it to exactly zero should enforce the nonlinear solver to iterate until no improvement on the termination criterion
            can be achieved; then, it terminates; this is described in
            Kikker, Kummer, Oberlack:
            A fully coupled high‐order discontinuous {Galerkin} solver for viscoelastic fluid flow,
            IJNMF, No. 6, Vol. 93, 2021, 1736--1758,
            section 3.3.1.
            </summary>
        </member>
        <member name="F:BoSSS.Solution.Control.NonLinearSolverConfig.UnderRelax">
            <summary>
            under relaxation, if a fixpoint iterator (e.g.Picard) is used.
            </summary>
        </member>
        <member name="F:BoSSS.Solution.Control.NonLinearSolverConfig.SolverCode">
            <summary>
            Sets the algorithm to use for nonlinear solving, e.g. Newton or Picard.
            </summary>
        </member>
        <member name="F:BoSSS.Solution.Control.NonLinearSolverConfig.constantNewtonIterations">
            <summary>
            Number of iterations, where Jacobi matrix is not updated. Also known as constant newton method. Default 1, means regular newton.
            </summary>
        </member>
        <member name="F:BoSSS.Solution.Control.NonLinearSolverConfig.HomotopyStepLongFail">
            <summary>
             If, for a specific homotopy parameter value, Newton does not converges successfully,
            (within this number of iterations) a roll-back to the last solution is done and the step with is reduced
            </summary>
        </member>
        <member name="F:BoSSS.Solution.Control.NonLinearSolverConfig.Globalization">
            <summary>
            How to restrict the step size of Newton steps
            </summary>
        </member>
        <member name="M:BoSSS.Solution.Control.NonLinearSolverConfig.Equals(BoSSS.Solution.Control.NonLinearSolverConfig)">
            <summary>
            Compares value not reference!
            </summary>
            <param name="compareto"></param>
            <returns></returns>
        </member>
    </members>
</doc>
